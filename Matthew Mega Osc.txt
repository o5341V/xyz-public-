//@version=5
indicator(title='Mega Osc', overlay=false,timeframe="")

rsx()=>
    src = input(close)
    length = input(10) 
    lvlob = input(80, title='OB Level')
    lvlos = input(20, title='OS Level')
    mid = input(50, title='Mid Level')
    clampmax = 100
    clampmin = 0
    f90 = 0.0
    f90_ = 0.0
    f88 = 0.0
    f28 = 0.0
    f30 = 0.0
    f38 = 0.0
    f40 = 0.0
    f48 = 0.0
    f10 = 0.0
    f50 = 0.0
    f58 = 0.0
    f60 = 0.0
    f68 = 0.0
    f70 = 0.0
    f78 = 0.0
    f80 = 0.0
    v20 = 0.0
    f90_ := nz(f90_[1]) == 0.0 ? 1.0 : nz(f88[1]) <= nz(f90_[1]) ? nz(f88[1]) + 1 : nz(f90_[1]) + 1
    f88 := nz(f90_[1]) == 0.0 and length - 1 >= 5 ? length - 1.0 : 5.0
    f8 = 0.0
    f8 := 100.0 * src
    f18 = 3.0 / (length + 2.0)
    f20 = 1.0 - f18
    f10 := nz(f8[1])
    v8 = f8 - f10
    f28 := f20 * nz(f28[1]) + f18 * v8
    f30 := f18 * f28 + f20 * nz(f30[1])
    vC = f28 * 1.5 - f30 * 0.5
    f38 := f20 * nz(f38[1]) + f18 * vC
    f40 := f18 * f38 + f20 * nz(f40[1])
    v10 = f38 * 1.5 - f40 * 0.5
    f48 := f20 * nz(f48[1]) + f18 * v10
    f50 := f18 * f48 + f20 * nz(f50[1])
    v14 = f48 * 1.5 - f50 * 0.5
    f58 := f20 * nz(f58[1]) + f18 * math.abs(v8)
    f60 := f18 * f58 + f20 * nz(f60[1])
    v18 = f58 * 1.5 - f60 * 0.5
    f68 := f20 * nz(f68[1]) + f18 * v18
    f70 := f18 * f68 + f20 * nz(f70[1])
    v1C = f68 * 1.5 - f70 * 0.5
    f78 := f20 * nz(f78[1]) + f18 * v1C
    f80 := f18 * f78 + f20 * nz(f80[1])
    v20 := f78 * 1.5 - f80 * 0.5
    f0 = f88 >= f90_ and f8 != f10 ? 1.0 : 0.0
    f90 := f88 == f90_ and f0 == 0.0 ? 0.0 : f90_
    v4_ = f88 < f90 and v20 > 0.0000000001 ? (v14 / v20 + 1.0) * 50.0 : 50.0
    rsx = v4_ > 100.0 ? 100.0 : v4_ < 0.0 ? 0.0 : v4_
    
fishfunc()=>
    heikon=true
    Length = input.int(6, minval=1)
    heikinashi = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)
    xHL2 = heikon ? heikinashi : close
    xMaxH = ta.highest(xHL2, Length)
    xMinL = ta.lowest(xHL2, Length)
    nValue1 = 0.0
    nValue1 := 0.33 * 2 * ((xHL2 - xMinL) / (xMaxH - xMinL) - 0.5) + 0.67 * nz(nValue1[1])
    iff_1 = nValue1 < -.99 ? -.999 : nValue1
    nValue2 = nValue1 > .99 ? .999 : iff_1
    nFish = 0.0
    nFish := 0.5 * math.log((1 + nValue2) / (1 - nValue2)) + 0.5 * nz(nFish[1])
    
stochrsi()=>
    smoothK = 3
    smoothD = 3
    lengthRSI = 14
    lengthStoch = 14
    src = close
    rsi1 = ta.rsi(src, 14)
    k = ta.sma(ta.stoch(rsi1, rsi1, rsi1, 14), smoothK)
    
nagasaki(bullorbear)=>
    main = hl2
    volumeSum2 = math.sum(volume, 47)
    volumeSum3 = math.sum(volume, 93)
    evwma2 = 0.0
    evwma3 = 0.0
    evwma2 := ((volumeSum2 - volume) * nz(evwma2[1]) + volume * main) / volumeSum2
    evwma3 := ((volumeSum3 - volume) * nz(evwma3[1]) + volume * main) / volumeSum3
    // dynamic_color1 = evwma2 > evwma3 ? uptrend : downtrend
    // dynamic_color2 = evwma2 > evwma3 ? uptrend : downtrend
    theOutput = bullorbear == 1 ? evwma2 : bullorbear == -1 ? evwma3 : math.avg(evwma2,evwma3)
    
mcginley() =>
    length = input.int(14, minval=1)
    source = close
    mg = 0.0
    mg := na(mg[1]) ? ta.ema(source, length) : mg[1] + (source - mg[1]) / (length * math.pow(source/mg[1], 4))

nagaDist() =>
    dist = nagasaki(0) - nagasaki(0)[1]
    
mcgDist() =>
    dist = mcginley() - mcginley()[1]

emaDist() =>
    dist = ta.ema(close,50) - ta.ema(close,50)[1]
    
corr() =>
    sym = 'SPY'
    src = close
    res = timeframe.period
    ovr = request.security(sym, res, src)
    out = ta.correlation(src, ovr, 20)

candlesgreenpct()=>
    candles = close > open ? 1 : 0
    candleSum1 = math.sum(candles,100)/100
    candleSum2 = math.sum(candles,75)/75
    candleSum3 = math.sum(candles,50)/50
    candleSum4 = math.sum(candles,25)/25
    out = 100*(candleSum1+candleSum2+candleSum3+candleSum4)/4

candleshigherpct()=>
    candles = hl2 > hl2[1] ? 1 : 0
    candleSum1 = math.sum(candles,100)/100
    candleSum2 = math.sum(candles,75)/75
    candleSum3 = math.sum(candles,50)/50
    candleSum4 = math.sum(candles,25)/25
    out = 100*(candleSum1+candleSum2+candleSum3+candleSum4)/4

ZLEMA(sauce, nPeriod) =>
    xLag = (nPeriod - 1) / 2
    xEMAData = sauce + sauce - sauce[xLag]
    xZLEMA = ta.ema(xEMAData, nPeriod)
    xZLEMA
    
bog(ap, len1, len2) =>
    esa1 = ta.sma(ap, len1)
    d1 = ta.sma(math.abs(ap - esa1), len1)
    ci1 = (ap - esa1) / (0.015 * d1)
    tci2 = ZLEMA(ci1, len2)
    tci2
    
thebog(x)=>
    boglettswitch = true
    modeswitch = false
    n1 = 10
    n2 = 26
    n3 = 3
    m1 = 10
    m2 = 26
    m3 = 3
    setbarindexmax = 1000
    Period = 0.0
    C1 = 0.0962
    C2 = 0.5769
    Df = 0.5
    C3 = nz(Period[1]) * 0.075 + 0.54
    smooth = (hl2 * 4.0 + hl2[1] * 3.0 + hl2[2] * 2.0 + hl2[3]) / 10.0
    dDeTrend = (smooth * C1 + nz(smooth[2]) * C2 - nz(smooth[4]) * C2 - nz(smooth[6]) * C1) * C3
    Q1 = (dDeTrend * C1 + nz(dDeTrend[2]) * C2 - nz(dDeTrend[4]) * C2 - nz(dDeTrend[6]) * C1) * C3
    I1 = nz(dDeTrend[3])
    jI = (I1 * C1 + nz(I1[2]) * C2 - nz(I1[4]) * C2 - nz(I1[6]) * C1) * C3
    jQ = (Q1 * C1 + nz(Q1[2]) * C2 - nz(Q1[4]) * C2 - nz(Q1[6]) * C1) * C3
    I2_ = I1 - jQ
    Q2_ = Q1 + jI
    I2 = 0.0
    if bar_index > setbarindexmax
        I2 := 0.2 * I2_ + 0.8 * nz(I2[1])
        I2
        Q2 = 0.0
        Q2 := 0.2 * Q2_ + 0.8 * nz(Q2[1])
        Q2
        Re_ = I2 * nz(I2[1]) + Q2 * nz(Q2[1])
        Im_ = I2 * nz(Q2[1]) - Q2 * nz(I2[1])
        Re = 0.0
        Re := 0.2 * Re_ + 0.8 * nz(Re[1])
        Im = 0.0
        Im := 0.2 * Im_ + 0.8 * nz(Im[1])
        dp_ = 0.0
        dp_ := Re != 0 and Im != 0 ? 6.28318 / math.atan(Im / Re) : 0
        II = nz(Period[1])
        dp = math.max(math.max(math.min(math.min(dp_, 1.5 * II), 50), 0.6667 * II), 6)
        Period := dp * 0.2 + nz(Period[1]) * 0.8
        Period
    SmoothPeriod = 0.0
    if bar_index > setbarindexmax
        SmoothPeriod := 0.33 * Period + nz(SmoothPeriod[1]) * 0.67
        SmoothPeriod
    BogLength = math.round(SmoothPeriod * Df - 1)
    o = open
    h = high
    l = low
    c = close
    looplength = 100
    num = 4
    for i = 0 to looplength by 1
        if i >= BogLength
            break
        num += 1
        num
    num *= 2
    ap = (h + l + c) / 3
    esa = ta.sma(ap, num)
    d = ta.sma(math.abs(ap - esa), num)
    ci = (ap - esa) / (0.015 * d)
    tci = ta.sma(ci, math.round(num))
    bog__1 = fixnan(bog(ap, n1, n2))
    /////////////////////////////////////////////////////////
    //Predictor line
    momentum = bog__1 - nz(bog__1[1])
    normalized = momentum * (num / (2 * 3.141592)) * 0.577  //arctan(30)
    reduce = normalized
    //reduce amplitude
    predictor = (bog__1 + reduce) * 0.877 * 0.75
    output = x == 1 ? bog__1 : predictor
    output

nf(Length)=>
    heikon=true
    heikinashi = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)
    xHL2 = heikon ? heikinashi : close
    xMaxH = ta.highest(xHL2, Length)
    xMinL = ta.lowest(xHL2, Length)
    nValue1 = 0.0
    nValue1 := 0.33 * 2 * ((xHL2 - xMinL) / (xMaxH - xMinL) - 0.5) + 0.67 * nz(nValue1[1])
    iff_1 = nValue1 < -.99 ? -.999 : nValue1
    nValue2 = nValue1 > .99 ? .999 : iff_1
    nFish = 0.0
    nFish := 0.5 * math.log((1 + nValue2) / (1 - nValue2)) + 0.5 * nz(nFish[1])
    
pctVar()=>
    lengthPct = 25
    oneBarVar = (high[1]-low[1])/hl2[1]
    output = (math.sum(oneBarVar,lengthPct)/lengthPct)*100
    output

pct_col(pct)=>
    colour = color.white
    colour := pct >= 0 and pct < 0.5 ? color.new(#fafa6e,0) :pct >= 0.5 and pct < 1 ? color.new(#ffe15b,0) :pct >= 1 and pct < 1.5 ? color.new(#ffc851,0) :pct >= 1.5 and pct < 2 ? color.new(#ffae4f,0) : pct >= 2 and pct < 2.5 ? color.new(#ff9453,0) :pct >= 2.5 and pct < 3 ? color.new(#ff7a5c,0) : pct >= 3 and pct < 3.5 ? color.new(#ff6166,0) : pct >= 3.5 and pct < 4 ? color.new(#f24a72,0) : pct >= 4 and pct < 4.5 ? color.new(#de377e,0): pct >= 4.5 and pct < 5 ? color.new(#d93480,0) : pct >= 5 ? color.new(#c42b89,0) : na
    out = colour
    out
    
bp(Length)=>
    Delta = input(0.05)
    xPrice = input(hl2)
    beta = math.cos(3.14 * (360 / Length) / 180)
    gamma = 1 / math.cos(3.14 * (720 * Delta / Length) / 180)
    alpha = gamma - math.sqrt(gamma * gamma - 1)
    BP = 0.0
    BP := 0.5 * (1 - alpha) * (xPrice - xPrice[2]) + beta * (1 + alpha) * nz(BP[1]) - alpha * nz(BP[2])

avgbp()=>
    bpchad = (math.avg(bp(12), bp(14), bp(16), bp(18), bp(20), bp(22),bp(24), bp(26), bp(28), bp(30), bp(32), bp(34),bp(36), bp(38), bp(40), bp(42), bp(44), bp(46),bp(48), bp(50), bp(52), bp(54), bp(56), bp(58)))
    xStdDev1 = ta.stdev(bpchad, 100)
    xMA1 = ta.sma(bpchad, 100)
    zScore1 = (bpchad - xMA1) / xStdDev1
    output = zScore1
    output

distBottom()=>
    bottom = ta.lowest(low, 15)
    currentPrice = close
    distancePct = (math.abs(currentPrice-bottom)/currentPrice)*100
    distancePct

//plot(avgbp(), color=zCol(avgbp()))
currentRes = timeframe.multiplier
 
bfl = 50

t(num)=>
    a = num > 1440 ? 1440 : num

//example: [a1,a2,a3,a4,a5,a6,a7,a8,a9,a10] = request.security(syminfo.ticker, input("1",title="Timeframe 1"), [f(len1),f(len2),f(len3),f(len4),f(len5),f(len6),f(len7),f(len8),f(len9),f(len10)])

//Timeframe 1 
mcgDist1x = mcgDist()
nagaDist1x = nagaDist()
emaDist1x = emaDist()
rsx1x = rsx()
corr1x = corr()
fishfunc1x = fishfunc()
highestfish1x = ta.highest(fishfunc(),50)
lowestfish1x = ta.lowest(fishfunc(),50)
stochrsi1x = stochrsi()
thebog1x = thebog(1)
bogpred1x = thebog(0)
nf1x = nf(bfl)
nf2_1x = nf(bfl*2)
nf3_1x = nf(bfl*3)
nf5_1x = nf(bfl*5)
nf10_1x = nf(bfl*10)
nf20_1x = nf(bfl*20)
pct1x = pctVar()
bp1x = avgbp()
db1x = distBottom()


// plot(stochrsi1x,color=color.green)
// plot(rsx1x,color=color.yellow)
// plot(thebog1x,color=color.red)
// plot(bp1x*50, color=color.blue)

testplot = ta.linreg(math.avg(stochrsi1x-50,rsx1x-50,thebog1x,bp1x*50),3,0)
p1 = plot(testplot, color=color.white)
p2 =plot(ta.ema(testplot,3), color=color.red)
fill(p1,p2, color=color.new(color.white,90))

main = hl2
//
volumeSum2 = math.sum(volume, 47)
volumeSum3 = math.sum(volume, 93)

evwma2 = 0.0
evwma3 = 0.0

evwma2 := ((volumeSum2 - volume) * nz(evwma2[1]) + volume * main) / volumeSum2
evwma3 := ((volumeSum3 - volume) * nz(evwma3[1]) + volume * main) / volumeSum3

dynamic_color1 = evwma2 > evwma3 ? color.new(#00ffcc,20) : color.new(#d74929,20)
dynamic_color2 = evwma2 > evwma3 ? color.new(#00ffcc,50) : color.new(#d74929,50)

dynamic_color3 = evwma2 > evwma3 ? color.new(#00ffcc,30) : color.new(#d74929,30)
dynamic_color4 = evwma2 > evwma3 ? color.new(#00ffcc,30) : color.new(#d74929,30)

//a1 = plot(evwma2, title="Top Line", color=dynamic_color1, offset=0)
//a2 = plot(evwma3, title="Bottom Line", color=dynamic_color1, offset=0)

//fill(a1, a2, color=dynamic_color2, transp=75)

plot(0,color=dynamic_color2)
p3 = plot(-50,color=dynamic_color2)
p4 = plot(50,color=dynamic_color2)

fill(p1, p4, color=testplot > 50 ? dynamic_color2 : na)
fill(p1, p3, color=testplot < -50 ? dynamic_color2 : na)
plotshape(ta.crossover(testplot, ta.ema(testplot,3)) ? testplot : na, location=location.absolute, color=dynamic_color2 , style=shape.circle, size=size.tiny)//