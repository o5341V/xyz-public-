// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © KioseffTrading

//@version=5
indicator("Fundamentals Graphing [Kioseff Trading]", overlay = false, max_lines_count = 500, max_labels_count = 500)


import kaigouthro/hsvColor/15 as kai

// THANK YOU TV + PineCoders (:

string FQ   = "Financial Quarter"
string FY   = "Financial Year"

// Financial legends.
string F_NA = "⸺"
string F000 = "█ INCOME STATEMENTS █"
string F001 = "After tax other income/expense"
string F002 = "Average basic shares outstanding"
string F003 = "Other COGS"
string F004 = "Cost of goods"
string F005 = "Deprecation and amortization"
string F006 = "Diluted net income available to common stockholders"
string F007 = "Diluted shares outstanding"
string F008 = "Dilution adjustment"
string F009 = "Discontinued operations"
string F010 = "Basic EPS"
string F011 = "Diluted EPS"
string F012 = "EBIT"
string F013 = "EBITDA"
string F014 = "Equity in earnings"
string F015 = "Gross profit"
string F016 = "Taxes"
string F017 = "Interest capitalized"
string F018 = "Interest expense on debt"
string F019 = "Non-controlling/minority interest"
string F020 = "Net income before discontinued operations"
string F021 = "Net income"
string F022 = "Non-operating income, excl. interest expenses"
string F023 = "Interest expense, net of interest capitalized"
string F024 = "Non-operating interest income"
string F025 = "Operating income"
string F026 = "Operating expenses (excl. COGS)"
string F027 = "Miscellaneous non-operating expense"
string F028 = "Other operating expenses, total"
string F029 = "Preferred dividends"
string F030 = "Pretax equity in earnings"
string F031 = "Pretax income"
string F032 = "Research & development"
string F033 = "Selling/general/admin expenses, other"
string F034 = "Selling/general/admin expenses, total"
string F035 = "Non-operating income, total"
string F036 = "Total operating expenses"
string F037 = "Total revenue"
string F038 = "Unusual income/expense"

string F100 = "█ BALANCE SHEET █"
string F101 = "Accounts payable"
string F102 = "Accounts receivable - trade, net"
string F103 = "Accrued payroll"
string F104 = "Accumulated depreciation, total"
string F105 = "Additional paid-in capital/Capital surplus"
string F106 = "Tangible book value per share"
string F107 = "Book value per share"
string F108 = "Capitalized lease obligations"
string F109 = "Capital and operating lease obligations"
string F110 = "Cash & equivalents"
string F111 = "Cash and short term investments"
string F112 = "Common equity, total"
string F113 = "Common stock par/Carrying value"
string F114 = "Current portion of LT debt and capital leases"
string F115 = "Deferred income, current"
string F116 = "Deferred income, non-current"
string F117 = "Deferred tax assets"
string F118 = "Deferred tax liabilities"
string F119 = "Dividends payable"
string F120 = "Goodwill, net"
string F121 = "Income tax payable"
string F122 = "Net intangible assets"
string F123 = "Inventories - finished goods"
string F124 = "Inventories - progress payments & other"
string F125 = "Inventories - raw materials"
string F126 = "Inventories - work in progress"
string F127 = "Investments in unconsolidated subsidiaries"
string F128 = "Long term debt excl. lease liabilities"
string F129 = "Long term debt"
string F130 = "Long term investments"
string F131 = "Note receivable - long term"
string F132 = "Other long term assets, total"
string F133 = "Minority interest"
string F134 = "Notes payable"
string F135 = "Operating lease liabilities"
string F136 = "Other common equity"
string F137 = "Other current assets, total"
string F138 = "Other current liabilities"
string F139 = "Other intangibles, net"
string F140 = "Other investments"
string F141 = "Other liabilities, total"
string F142 = "Other receivables"
string F143 = "Other short term debt"
string F144 = "Paid in capital"
string F145 = "Gross property/plant/equipment"
string F146 = "Net property/plant/equipment"
string F147 = "Preferred stock, carrying value"
string F148 = "Prepaid expenses"
string F149 = "Provision for risks & charge"
string F150 = "Retained earnings"
string F151 = "Short term debt excl. current portion of LT debt"
string F152 = "Short term debt"
string F153 = "Short term investments"
string F154 = "Shareholders' equity"
string F155 = "Total assets"
string F156 = "Total current assets"
string F157 = "Total current liabilities"
string F158 = "Total debt"
string F159 = "Total equity"
string F160 = "Total inventory"
string F161 = "Total liabilities"
string F162 = "Total liabilities & shareholders' equities"
string F163 = "Total non-current assets"
string F164 = "Total non-current liabilities"
string F165 = "Total receivables, net"
string F166 = "Treasury stock - common"

string F200 = "█ CASHFLOW █"
string F201 = "Amortization"
string F202 = "Capital expenditures - fixed assets"
string F203 = "Capital expenditures"
string F204 = "Capital expenditures - other assets"
string F205 = "Cash from financing activities"
string F206 = "Cash from investing activities"
string F207 = "Cash from operating activities"
string F208 = "Deferred taxes (cash flow)"
string F209 = "Depreciation & amortization (cash flow)"
string F210 = "Change in accounts payable"
string F211 = "Change in accounts receivable"
string F212 = "Change in accrued expenses"
string F213 = "Change in inventories"
string F214 = "Change in other assets/liabilities"
string F215 = "Change in taxes payable"
string F216 = "Changes in working capital"
string F217 = "Common dividends paid"
string F218 = "Depreciation/depletion"
string F219 = "Free cash flow"
string F220 = "Funds from operations"
string F221 = "Issuance/retirement of debt, net"
string F222 = "Issuance/retirement of long term debt"
string F223 = "Issuance/retirement of other debt"
string F224 = "Issuance/retirement of short term debt"
string F225 = "Issuance/retirement of stock, net"
string F226 = "Net income (cash flow)"
string F227 = "Non-cash items"
string F228 = "Other financing cash flow items, total"
string F229 = "Financing activities - other sources"
string F230 = "Financing activities - other uses"
string F231 = "Other investing cash flow items, total"
string F232 = "Investing activities - other sources"
string F233 = "Investing activities - other uses"
string F234 = "Preferred dividends paid"
string F235 = "Purchase/acquisition of business"
string F236 = "Purchase of investments"
string F237 = "Repurchase of common & preferred stock"
string F238 = "Purchase/sale of business, net"
string F239 = "Purchase/sale of investments, net"
string F240 = "Reduction of long term debt"
string F241 = "Sale of common & preferred stock"
string F242 = "Sale of fixed assets & businesses"
string F243 = "Sale/maturity of investments"
string F244 = "Issuance of long term debt"
string F245 = "Total cash dividends paid"

string F300 = "█ STATISTICS █"
string F301 = "Accruals"
string F302 = "Altman Z-score"
string F303 = "Asset turnover"
string F304 = "Beneish M-score"
string F305 = "Buyback yield %"
string F306 = "Cash conversion cycle"
string F307 = "Cash to debt ratio"
string F308 = "COGS to revenue ratio"
string F309 = "Current ratio"
string F310 = "Days sales outstanding"
string F311 = "Days inventory"
string F312 = "Days payable"
string F313 = "Debt to assets ratio"
string F314 = "Debt to EBITDA ratio"
string F315 = "Debt to equity ratio"
string F316 = "Debt to revenue ratio"
string F317 = "Dividend payout ratio %"
string F318 = "Dividend yield %"
string F319 = "Dividends per share - common stock primary issue"
string F320 = "EPS estimates"
string F321 = "EPS basic one year growth"
string F322 = "EPS diluted one year growth"
string F323 = "EBITDA margin %"
string F324 = "Effective interest rate on debt %"
string F325 = "Enterprise value to EBITDA ratio"
string F326 = "Enterprise value"
string F327 = "Equity to assets ratio"
string F328 = "Enterprise value to EBIT ratio"
string F329 = "Enterprise value to revenue ratio"
string F330 = "Float shares outstanding"
string F331 = "Free cash flow margin %"
string F332 = "Fulmer H factor"
string F333 = "Goodwill to assets ratio"
string F334 = "Graham's number"
string F335 = "Gross margin %"
string F336 = "Gross profit to assets ratio"
string F337 = "Interest coverage"
string F338 = "Inventory to revenue ratio"
string F339 = "Inventory turnover"
string F340 = "KZ index"
string F341 = "Long term debt to total assets ratio"
string F342 = "Net current asset value per share"
string F343 = "Net income per employee"
string F344 = "Net margin %"
string F345 = "Number of employees"
string F346 = "Operating earnings yield %"
string F347 = "Operating margin %"
string F348 = "PEG ratio"
string F349 = "Piotroski F-score"
string F350 = "Price earnings ratio forward"
string F351 = "Price sales ratio forward"
string F352 = "Price to free cash flow ratio"
string F353 = "Price to tangible book ratio"
string F354 = "Quality ratio"
string F355 = "Quick ratio"
string F356 = "Research & development to revenue ratio"
string F357 = "Return on assets %"
string F358 = "Return on equity adjusted to book value %"
string F359 = "Return on equity %"
string F360 = "Return on invested capital %"
string F361 = "Return on tangible assets %"
string F362 = "Return on tangible equity %"
string F363 = "Revenue one year growth"
string F364 = "Revenue per employee"
string F365 = "Revenue estimates"
string F366 = "Shares buyback ratio %"
string F367 = "Sloan ratio %"
string F368 = "Springate score"
string F369 = "Sustainable growth rate"
string F370 = "Tangible common equity ratio"
string F371 = "Tobin's Q (approximate)"
string F372 = "Total common shares outstanding"
string F373 = "Zmijewski score"


string typeInput1        = input.string(F010 , "Data    ", inline = "100", group = "Initial Settings",
       options           =    [F_NA,
       F000, F001, F002, F003, F004, F005, F006, F007, F008, F009, F010, F011, F012, F013, F014, F015, F016, F017, F018, F019, F020, F021, F022, F023, F024, F025, F026, F027, F028, F029, F030, F031, F032, F033, F034, F035, F036, F037, F038, 
       F100, F101, F102, F103, F104, F105, F106, F107, F108, F109, F110, F111, F112, F113, F114, F115, F116, F117, F118, F119, F120, F121, F122, F123, F124, F125, F126, F127, F128, F129, F130, F131, F132, F133, F134, F135, F136, F137, F138, F139, F140, F141, F142, F143, F144, F145, F146, F147, F148, F149, F150, F151, F152, F153, F154, F155, F156, F157, F158, F159, F160, F161, F162, F163, F164, F165, F166,
       F200, F201, F202, F203, F204, F205, F206, F207, F208, F209, F210, F211, F212, F213, F214, F215, F216, F217, F218, F219, F220, F221, F222, F223, F224, F225, F226, F227, F228, F229, F230, F231, F232, F233, F234, F235, F236, F237, F238, F239, F240, F241, F242, F243, F244, F245,
       F300, F301, F302, F303, F304, F305, F306, F307, F308, F309, F310, F311, F312, F313, F314, F315, F316, F317, F318, F319, F320, F321, F322, F323, F324, F325, F326, F327, F328, F329, F330, F331, F332, F333, F334, F335, F336, F337, F338, F339, F340, F341, F342, F343, F344, F345, F346, F347, F348, F349, F350, F351, F352, F353, F354, F355, F356, F357, F358, F359, F360, F361, F362, F363, F364, F365, F366, F367, F368, F369, F370, F371, F372, F373])


px                   = input.string(defval = "Technology Services", title = "Preset", group = "Initial Settings",
                                     options = ["Technology Services", "Electronic Technology", "Financial Services", "Health Technology", "Consumer Non-Durables", "Energy Minerals", "Consumer Durables", "Commercial Services", "Retail Trade", "Transportation", "Utilities", "Custom"], inline = "100")
period               = input.string(defval = "Fiscal Quarter", title = "Period  ", options = ["Fiscal Quarter", "Fiscal Year"], inline = "70", group = "Initial Settings")
intervalsback        = input.int   (defval = 0, minval = 0, title = "Intervals Back    ", inline = "70", group = "Initial Settings")
reverse              = input.bool  (defval = false, title = "Reverse Colors"     , inline = "33", group = "Initial Settings")
revScale             = input.bool  (defval = false, title = "Reverse Scale"      , inline = "33", group = "Initial Settings")

columns              = input.string(defval = "Scatter + Columns", title = "Plot Type", group = "Plot Type",
                                     options= ["Scatter", "Columns", "Scatter + Columns", "Bar", "Pie Chart","Drop Down"])
sort                 = input.string(defval = "None", title = "Sort Data        ", options = ["None", "Descending", "Ascending"], group = "Scatter / Columns / Bars")
boxnobg              = input.bool  (defval = false, title = "Move Data to Box",             group = "Scatter / Columns / Bars"          )

searchF              = input.bool  (defval = false, title = "Use Search Function", inline = "40", group = "Search Function" )
search               = input.string(defval = "", title = "Search Function"       , inline = "40", group = "Search Function" )
upcolor              = input.color (defval = color.lime, title = "Up Color    "    , inline = "90", group = "Colors"          )
downcolor            = input.color (defval = color.red, title = "Down Color"   , inline = "90", group = "Colors"          )
midCol               = input.color (defval = color.white, title = "Median Color", inline = "90", group = "Colors"         )

usebg                = input.bool  (defval = true, title = "Use Background Color", inline = "91", group = "Colors"         )
cbg                  = input.color (defval = #000000, title = "Background Color"    , inline = "91", group = "Colors"          )

var timeArray        = array.new_int()

getId(simple string userFinancialChoice) =>

    string result = switch userFinancialChoice
        F001 => "AFTER_TAX_OTHER_INCOME" 
        F002 => "BASIC_SHARES_OUTSTANDING" 
        F003 => "COST_OF_GOODS_EXCL_DEP_AMORT" 
        F004 => "COST_OF_GOODS" 
        F005 => "DEP_AMORT_EXP_INCOME_S" 
        F006 => "DILUTED_NET_INCOME" 
        F007 => "DILUTED_SHARES_OUTSTANDING" 
        F008 => "DILUTION_ADJUSTMENT" 
        F009 => "DISCONTINUED_OPERATIONS" 
        F010 => "EARNINGS_PER_SHARE_BASIC" 
        F011 => "EARNINGS_PER_SHARE_DILUTED" 
        F012 => "EBIT" 
        F013 => "EBITDA" 
        F014 => "EQUITY_IN_EARNINGS" 
        F015 => "GROSS_PROFIT" 
        F016 => "INCOME_TAX" 
        F017 => "INTEREST_CAPITALIZED" 
        F018 => "INTEREST_EXPENSE_ON_DEBT" 
        F019 => "MINORITY_INTEREST_EXP" 
        F020 => "NET_INCOME_BEF_DISC_OPER" 
        F021 => "NET_INCOME" 
        F022 => "NON_OPER_INCOME" 
        F023 => "NON_OPER_INTEREST_EXP" 
        F024 => "NON_OPER_INTEREST_INCOME" 
        F025 => "OPER_INCOME" 
        F026 => "OPERATING_EXPENSES" 
        F027 => "OTHER_INCOME" 
        F028 => "OTHER_OPER_EXPENSE_TOTAL" 
        F029 => "PREFERRED_DIVIDENDS" 
        F030 => "PRETAX_EQUITY_IN_EARNINGS" 
        F031 => "PRETAX_INCOME" 
        F032 => "RESEARCH_AND_DEV" 
        F033 => "SELL_GEN_ADMIN_EXP_OTHER" 
        F034 => "SELL_GEN_ADMIN_EXP_TOTAL" 
        F035 => "TOTAL_NON_OPER_INCOME" 
        F036 => "TOTAL_OPER_EXPENSE" 
        F037 => "TOTAL_REVENUE" 
        F038 => "UNUSUAL_EXPENSE_INC" 

        F101 => "ACCOUNTS_PAYABLE" 
        F102 => "ACCOUNTS_RECEIVABLES_NET" 
        F103 => "ACCRUED_PAYROLL" 
        F104 => "ACCUM_DEPREC_TOTAL" 
        F105 => "ADDITIONAL_PAID_IN_CAPITAL" 
        F106 => "BOOK_TANGIBLE_PER_SHARE" 
        F107 => "BOOK_VALUE_PER_SHARE" 
        F108 => "CAPITAL_LEASE_OBLIGATIONS" 
        F109 => "CAPITAL_OPERATING_LEASE_OBLIGATIONS" 
        F110 => "CASH_N_EQUIVALENTS" 
        F111 => "CASH_N_SHORT_TERM_INVEST" 
        F112 => "COMMON_EQUITY_TOTAL" 
        F113 => "COMMON_STOCK_PAR" 
        F114 => "CURRENT_PORT_DEBT_CAPITAL_LEASES" 
        F115 => "DEFERRED_INCOME_CURRENT" 
        F116 => "DEFERRED_INCOME_NON_CURRENT" 
        F117 => "DEFERRED_TAX_ASSESTS" 
        F118 => "DEFERRED_TAX_LIABILITIES" 
        F119 => "DIVIDENDS_PAYABLE" 
        F120 => "GOODWILL" 
        F121 => "INCOME_TAX_PAYABLE" 
        F122 => "INTANGIBLES_NET" 
        F123 => "INVENTORY_FINISHED_GOODS" 
        F124 => "INVENTORY_PROGRESS_PAYMENTS" 
        F125 => "INVENTORY_RAW_MATERIALS" 
        F126 => "INVENTORY_WORK_IN_PROGRESS" 
        F127 => "INVESTMENTS_IN_UNCONCSOLIDATE" 
        F128 => "LONG_TERM_DEBT_EXCL_CAPITAL_LEASE" 
        F129 => "LONG_TERM_DEBT" 
        F130 => "LONG_TERM_INVESTMENTS" 
        F131 => "LONG_TERM_NOTE_RECEIVABLE" 
        F132 => "LONG_TERM_OTHER_ASSETS_TOTAL" 
        F133 => "MINORITY_INTEREST" 
        F134 => "NOTES_PAYABLE_SHORT_TERM_DEBT" 
        F135 => "OPERATING_LEASE_LIABILITIES" 
        F136 => "OTHER_COMMON_EQUITY" 
        F137 => "OTHER_CURRENT_ASSETS_TOTAL" 
        F138 => "OTHER_CURRENT_LIABILITIES" 
        F139 => "OTHER_INTANGIBLES_NET" 
        F140 => "OTHER_INVESTMENTS" 
        F141 => "OTHER_LIABILITIES_TOTAL" 
        F142 => "OTHER_RECEIVABLES" 
        F143 => "OTHER_SHORT_TERM_DEBT" 
        F144 => "PAID_IN_CAPITAL" 
        F145 => "PPE_TOTAL_GROSS" 
        F146 => "PPE_TOTAL_NET" 
        F147 => "PREFERRED_STOCK_CARRYING_VALUE" 
        F148 => "PREPAID_EXPENSES" 
        F149 => "PROVISION_F_RISKS" 
        F150 => "RETAINED_EARNINGS" 
        F151 => "SHORT_TERM_DEBT_EXCL_CURRENT_PORT" 
        F152 => "SHORT_TERM_DEBT" 
        F153 => "SHORT_TERM_INVEST" 
        F154 => "SHRHLDRS_EQUITY" 
        F155 => "TOTAL_ASSETS" 
        F156 => "TOTAL_CURRENT_ASSETS" 
        F157 => "TOTAL_CURRENT_LIABILITIES" 
        F158 => "TOTAL_DEBT" 
        F159 => "TOTAL_EQUITY" 
        F160 => "TOTAL_INVENTORY" 
        F161 => "TOTAL_LIABILITIES" 
        F162 => "TOTAL_LIABILITIES_SHRHLDRS_EQUITY" 
        F163 => "TOTAL_NON_CURRENT_ASSETS" 
        F164 => "TOTAL_NON_CURRENT_LIABILITIES" 
        F165 => "TOTAL_RECEIVABLES_NET" 
        F166 => "TREASURY_STOCK_COMMON" 

        F201 => "AMORTIZATION" 
        F202 => "CAPITAL_EXPENDITURES_FIXED_ASSETS" 
        F203 => "CAPITAL_EXPENDITURES" 
        F204 => "CAPITAL_EXPENDITURES_OTHER_ASSETS" 
        F205 => "CASH_F_FINANCING_ACTIVITIES" 
        F206 => "CASH_F_INVESTING_ACTIVITIES" 
        F207 => "CASH_F_OPERATING_ACTIVITIES" 
        F208 => "CASH_FLOW_DEFERRED_TAXES" 
        F209 => "CASH_FLOW_DEPRECATION_N_AMORTIZATION" 
        F210 => "CHANGE_IN_ACCOUNTS_PAYABLE" 
        F211 => "CHANGE_IN_ACCOUNTS_RECEIVABLE" 
        F212 => "CHANGE_IN_ACCRUED_EXPENSES" 
        F213 => "CHANGE_IN_INVENTORIES" 
        F214 => "CHANGE_IN_OTHER_ASSETS" 
        F215 => "CHANGE_IN_TAXES_PAYABLE" 
        F216 => "CHANGES_IN_WORKING_CAPITAL" 
        F217 => "COMMON_DIVIDENDS_CASH_FLOW" 
        F218 => "DEPRECIATION_DEPLETION" 
        F219 => "FREE_CASH_FLOW" 
        F220 => "FUNDS_F_OPERATIONS" 
        F221 => "ISSUANCE_OF_DEBT_NET" 
        F222 => "ISSUANCE_OF_LONG_TERM_DEBT" 
        F223 => "ISSUANCE_OF_OTHER_DEBT" 
        F224 => "ISSUANCE_OF_SHORT_TERM_DEBT" 
        F225 => "ISSUANCE_OF_STOCK_NET" 
        F226 => "NET_INCOME_STARTING_LINE" 
        F227 => "NON_CASH_ITEMS" 
        F228 => "OTHER_FINANCING_CASH_FLOW_ITEMS_TOTAL" 
        F229 => "OTHER_FINANCING_CASH_FLOW_SOURCES" 
        F230 => "OTHER_FINANCING_CASH_FLOW_USES" 
        F231 => "OTHER_INVESTING_CASH_FLOW_ITEMS_TOTAL" 
        F232 => "OTHER_INVESTING_CASH_FLOW_SOURCES" 
        F233 => "OTHER_INVESTING_CASH_FLOW_USES" 
        F234 => "PREFERRED_DIVIDENDS_CASH_FLOW" 
        F235 => "PURCHASE_OF_BUSINESS" 
        F236 => "PURCHASE_OF_INVESTMENTS" 
        F237 => "PURCHASE_OF_STOCK" 
        F238 => "PURCHASE_SALE_BUSINESS" 
        F239 => "PURCHASE_SALE_INVESTMENTS" 
        F240 => "REDUCTION_OF_LONG_TERM_DEBT" 
        F241 => "SALE_OF_STOCK" 
        F242 => "SALES_OF_BUSINESS" 
        F243 => "SALES_OF_INVESTMENTS" 
        F244 => "SUPPLYING_OF_LONG_TERM_DEBT" 
        F245 => "TOTAL_CASH_DIVIDENDS_PAID" 

        F301 => "ACCRUALS_RATIO" 
        F302 => "ALTMAN_Z_SCORE" 
        F303 => "ASSET_TURNOVER" 
        F304 => "BENEISH_M_SCORE" 
        F305 => "BUYBACK_YIELD" 
        F306 => "CASH_CONVERSION_CYCLE" 
        F307 => "CASH_TO_DEBT" 
        F308 => "COGS_TO_REVENUE" 
        F309 => "CURRENT_RATIO" 
        F310 => "DAY_SALES_OUT" 
        F311 => "DAYS_INVENT" 
        F312 => "DAYS_PAY" 
        F313 => "DEBT_TO_ASSET" 
        F314 => "DEBT_TO_EBITDA" 
        F315 => "DEBT_TO_EQUITY" 
        F316 => "DEBT_TO_REVENUE" 
        F317 => "DIVIDEND_PAYOUT_RATIO" 
        F318 => "DIVIDENDS_YIELD" 
        F319 => "DPS_COMMON_STOCK_PRIM_ISSUE" 
        F320 => "EARNINGS_ESTIMATE" 
        F321 => "EARNINGS_PER_SHARE_BASIC_ONE_YEAR_GROWTH" 
        F322 => "EARNINGS_PER_SHARE_DILUTED_ONE_YEAR_GROWTH" 
        F323 => "EBITDA_MARGIN" 
        F324 => "EFFECTIVE_INTEREST_RATE_ON_DEBT" 
        F325 => "ENTERPRISE_VALUE_EBITDA" 
        F326 => "ENTERPRISE_VALUE" 
        F327 => "EQUITY_TO_ASSET" 
        F328 => "EV_EBIT" 
        F329 => "EV_REVENUE" 
        F330 => "FLOAT_SHARES_OUTSTANDING" 
        F331 => "FREE_CASH_FLOW_MARGIN" 
        F332 => "FULMER_H_FACTOR" 
        F333 => "GOODWILL_TO_ASSET" 
        F334 => "GRAHAM_NUMBERS" 
        F335 => "GROSS_MARGIN" 
        F336 => "GROSS_PROFIT_TO_ASSET" 
        F337 => "INTERST_COVER" 
        F338 => "INVENT_TO_REVENUE" 
        F339 => "INVENT_TURNOVER" 
        F340 => "KZ_INDEX" 
        F341 => "LONG_TERM_DEBT_TO_ASSETS" 
        F342 => "NCAVPS_RATIO" 
        F343 => "NET_INCOME_PER_EMPLOYEE" 
        F344 => "NET_MARGIN" 
        F345 => "NUMBER_OF_EMPLOYEES" 
        F346 => "OPERATING_EARNINGS_YIELD" 
        F347 => "OPERATING_MARGIN" 
        F348 => "PEG_RATIO" 
        F349 => "PIOTROSKI_F_SCORE" 
        F350 => "PRICE_EARNINGS_FORWARD" 
        F351 => "PRICE_SALES_FORWARD" 
        F352 => "PRICE_TO_FREE_CASH_FLOW" 
        F353 => "PRICE_TO_TANGIBLE_BOOK" 
        F354 => "QUALITY_RATIO" 
        F355 => "QUICK_RATIO" 
        F356 => "RESEARCH_AND_DEVELOP_TO_REVENUE" 
        F357 => "RETURN_ON_ASSETS" 
        F358 => "RETURN_ON_EQUITY_ADJUST_TO_BOOK" 
        F359 => "RETURN_ON_EQUITY" 
        F360 => "RETURN_ON_INVESTED_CAPITAL" 
        F361 => "RETURN_ON_TANG_ASSETS" 
        F362 => "RETURN_ON_TANG_EQUITY" 
        F363 => "REVENUE_ONE_YEAR_GROWTH" 
        F364 => "REVENUE_PER_EMPLOYEE" 
        F365 => "SALES_ESTIMATES" 
        F366 => "SHARE_BUYBACK_RATIO" 
        F367 => "SLOAN_RATIO" 
        F368 => "SPRINGATE_SCORE" 
        F369 => "SUSTAINABLE_GROWTH_RATE" 
        F370 => "TANGIBLE_COMMON_EQUITY_RATIO" 
        F371 => "TOBIN_Q_RATIO" 
        F372 => "TOTAL_SHARES_OUTSTANDING" 
        F373 => "ZMIJEWSKI_SCORE" 
        =>      ""


upcol = switch reverse 
    false => revScale == false ? upcolor   : downcolor
    =>       revScale == false ? downcolor : upcolor

dncol = switch reverse 
    false => revScale == false ? downcolor : upcolor
    =>       revScale == false ? upcolor : downcolor 


per = switch period
   
    "Fiscal Quarter"        => "FQ"
    "Fiscal Year"           => "FY"


var float max = 0.0, var float min = 1e8

if time >= chart.left_visible_bar_time
    timeArray.unshift(math.round(time))
    max := math.max(high, max)
    min := math.min(low,  min)

calc = (max - min) / 10, st = "Symbols"


tf(string , string1, string2, string3, string4, string5, string6, string7, string8, string9, string10, stringx) => 

    prefix = "BATS:"
    switch px 

        "Technology Services"    => prefix + string   
        "Financial Services"     => prefix + string1  
        "Electronic Technology"  => prefix + string2      
        "Health Technology"      => prefix + string3      
        "Consumer Non-Durables"  => prefix + string4  
        "Energy Minerals"        => prefix + string5
        "Consumer Durables"      => prefix + string6
        "Commercial Services"    => prefix + string7
        "Retail Trade"           => prefix + string8
        "Transportation"         => prefix + string9
        "Utilities"              => prefix + string10

        =>                          stringx


type values
   
    float    symbolData
    string   symbol
    string   yearCount
    box      colmn
    color    symbolColor
    line     shapeLines
    linefill shapeLinesFill
    label    symbolLabel
    float    top
    float    bot
    int      l
    int      r
    array <float>  dataArr
    array <string> symbolArr

symbolMat = matrix.new<values>(2, 40)

req( x, simple string symbol ) => 
    
    n = request.financial(symbol, searchF == false ? getId(typeInput1) : getId(search), per, ignore_invalid_symbol = true)
    symbolMat.set(0, x, values.new(symbolData = n)), symbolMat.set(1, x, values.new(symbol = symbol))
    
    [n, symbol]


req(0 , tf("MSFT"   ,"BRK.B"   , "AAPL" , "JNJ"  , "CROX"  , "XOM" , "TSLA", "PYPL", "AMZN" , "UBER", "NEE" , input.symbol(defval = "MSFT", title = "Symbol 1",  inline = "0" , group = st))), [d1 ,s1 ] = req(1 , tf("GOOGL"  ,"JPM"   , "NVDA" , "LLY" , "BGS"   , "HES"  , "HAS"  , "NSSC", "W"    , "INSW" , "TRGP", input.symbol(defval = "AAPL", title = "Symbol 2 ", inline = "0" , group = st)))
req(2 , tf("META"   ,"BAC"     , "AVGO" , "ABBV" , "PG"    , "OXY" , "RIVN", "TRKA", "BBBY" , "AAL" , "RUN" , input.symbol(defval = "NVDA", title = "Symbol 3 ", inline = "2 ", group = st))), [d3 ,s3 ] = req(3 , tf("PAYX"   ,"WFC"   , "CSCO" , "MRK" , "CELH"  , "AMR"  , "RACE" , "ASST", "BBY"  , "SKYW" , "FE"  , input.symbol(defval = "V"   , title = "Symbol 4 ", inline = "2 ", group = st)))
req(4 , tf("ADBE"   ,"MS"      , "TXN"  , "DHR"  , "ELF"   , "CVX" , "LCID", "V"   , "GME"  , "LYFT", "D"   , input.symbol(defval = "MA"  , title = "Symbol 5 ", inline = "4 ", group = st))), [d5 ,s5 ] = req(5 , tf("INTU"   ,"SCHW"  , "RTX"  , "ABT" , "KO"    , "TELL" , "IDEX" , "MCO" , "CHWY" , "CSX"  , "PEG" , input.symbol(defval = "META", title = "Symbol 6 ", inline = "4 ", group = st)))
req(6 , tf("NFLX"   ,"AXP"     , "QCOM" , "BMY"  , "PEP"   , "DVN" , "F"   , "MA"  , "COST" , "ZIM" , "ES"  , input.symbol(defval = "SBUX", title = "Symbol 7 ", inline = "6 ", group = st))), [d7 ,s7 ] = req(7 , tf("ORCL"   ,"GS"    , "HON"  , "PFE" , "KHC"   , "AMPY" , "KBH"  , "MEDP", "WBA"  , "TDW"  , "MDU" , input.symbol(defval = "JNJ" , title = "Symbol 8 ", inline = "6 ", group = st)))
req(8 , tf("CRM"    ,"PLD"     , "INTC" , "TMO"  , "VFC"   , "COP" , "ROKU", "FOUR", "WMT"  , "UAL" , "DUK" , input.symbol(defval = "T"   , title = "Symbol 9 ", inline = "8 ", group = st))), [d9 ,s9 ] = req(9, tf("IBM"    ,"BLK"   , "ADI"  , "AMGN", "COTY"  , "ARCH" , "RIDE" , "EB"  , "EBAY" , "ODFL" , "SRE" , input.symbol(defval = "HD"  , title = "Symbol 10", inline = "8 ", group = st)))
req(10, tf("ACN"    ,"C"       , "NOC"  , "REGN" , "COCO"  , "VLO" , "GM"  , "MQ"  , "TGT"  , "DAL" , "SO"  , input.symbol(defval = "Z"   , title = "Symbol 11", inline = "10", group = st))), [d11,s11] = req(11, tf("ROP"    ,"AMT"   , "AMD"  , "ISRG", "NKE"   , "RRC"  , "ARVL" , "IPDN", "ULTA" , "FLNG" , "EIX" , input.symbol(defval = "AMZN", title = "Symbol 12", inline = "10", group = st)))
req(12, tf("ATVI"   ,"CB"      , "BA"   , "ZTS"  , "GLS"   , "BTU" , "FSR" , "CHGG", "HD"   , "FDX" , "CEG" , input.symbol(defval = "TSLA", title = "Symbol 13", inline = "12", group = st))), [d13,s13] = req(13, tf("SNPS"   ,"PGR"   , "LMT"  , "MDT" , "PM"    , "CRK"  , "GPRO" , "TWKS", "WISH" , "DHT"  , "AQN" , input.symbol(defval = "AMD" , title = "Symbol 14", inline = "12", group = st)))
req(14, tf("CDNS"   ,"MMC"     , "GD"   , "GILD" , "PM"    , "MPC" , "NKLA", "CPRT", "CVNA" , "HLBZ", "AEP" , input.symbol(defval = "GOOG", title = "Symbol 15", inline = "14", group = st))), [d15,s15] = req(15, tf("ADSK"   ,"USB"   , "MU"   , "SYK" , "UL"    , "PR"   , "WHR"  , "WEX" , "AAP"  , "LPG"  , "PPL" , input.symbol(defval = "NIO" , title = "Symbol 16", inline = "14", group = st)))
req(16, tf("NOW"    ,"FISV"    , "KLAC" , "VRTX" , "BROS"  , "MRO" , "GOEV", "PGNY", "LOW"  , "UPS" , "AWK" , input.symbol(defval = "BABA", title = "Symbol 17", inline = "16", group = st))), [d17,s17] = req(17, tf("EQIX"   ,"CME"   , "FTNT" , "BDX" , "BUD"   ,  "VET" , "LZB"  , "STGW", "CPNG" , "JBLU" , "NEP" , input.symbol(defval = "IBM" , title = "Symbol 18", inline = "16", group = st)))
req(18, tf("ADP"    ,"AON"     , "EMR"  , "MRNA" , "ONON"  , "EQT" , "DHI" , "PAYO", "BYND" , "UNP" , "CLNE", input.symbol(defval = "AFRM", title = "Symbol 19", inline = "18", group = st))), [d19,s19] = req(19, tf("MSCI"   ,"PNC"   , "MCHP" , "EW"  , "MDLZ"  ,  "KOS" , "FTDR" , "HURN", "FTCH" , "GSL"  , "NI"  , input.symbol(defval = "ABNB", title = "Symbol 20", inline = "18", group = st)))
req(20, tf("CTSH"   ,"CCI"     , "NXPI" , "DXCM" , "TSN"   , "CTRA", "WKHS", "FIS" , "M"    , "LUV" , "EXC" , input.symbol(defval = "MSFT", title = "Symbol 21", inline = "20", group = st))), [d21,s21] = req(21, tf("VRSK"   ,"SPG"   , "HPE"  , "A"   , "UAA"   , "OVV"  , "TPX"  , "OMC" , "BLDR" , "GOGL" , "ETR" , input.symbol(defval = "AAPL", title = "Symbol 22", inline = "20", group = st)))
req(22, tf("IT"     ,"ICE"     , "ANET" , "BIIB" , "CLX"   , "PXD" , "ARHS", "SPGI", "DLTR" , "ASC" , "PCG" , input.symbol(defval = "NVDA", title = "Symbol 23", inline = "22", group = st))), [d23,s23] = req(23, tf("ANSS"   ,"AJG"   , "KEYS" , "RMD" , "EL"    , "CNQ"  , "DPRO" , "TASK", "DG"   , "SYY"  , "CNP" , input.symbol(defval = "V"   , title = "Symbol 24", inline = "22", group = st)))
req(24, tf("EA"     ,"MET"     , "MSI"  , "ILMN" , "IPAR"  , "EOG" , "LEN" , "WE"  , "KSS"  , "STNG", "NFE" , input.symbol(defval = "MA"  , title = "Symbol 25", inline = "24", group = st))), [d25,s25] = req(25, tf("VRSN"   ,"PRU"   , "FTV"  , "MTD" , "BTI"   , "CEI"  , "GT"   , "AMN" , "TJX"  , "SAVE" , "LNT" , input.symbol(defval = "META", title = "Symbol 26", inline = "24", group = st)))
req(26, tf("EPAM"   ,"PSA"     , "ROK"  , "ALGN" , "K"     , "AR"  , "VSTO", "BTBT", "ETSY" , "FRO" , "AES" , input.symbol(defval = "SBUX", title = "Symbol 27", inline = "26", group = st))), [d27,s27] = req(27, tf("BR"     ,"AMP"   , "GRMN" , "WST" , "MO"    , "WMB"  , "HOG"  , "PIXY", "JWN"  , "EURN" , "AEE" , input.symbol(defval = "JNJ" , title = "Symbol 28", inline = "26", group = st)))
req(28, tf("FDS"    ,"AIG"     , "ON"   , "BAX"  , "HBI"   , "SWN" , "FFIE", "RELY", "CHPT" , "BAER", "NOVA", input.symbol(defval = "T"   , title = "Symbol 29", inline = "28", group = st))), [d29,s29] = req(29, tf("CSGP"   ,"WELL"  , "FLSR" , "HOLX", "KDP"   , "CHK"  , "CENN" , "MLEC", "AZO"  , "IMPP" , "ATO" , input.symbol(defval = "HD"  , title = "Symbol 30", inline = "28", group = st)))
req(30, tf("TTWO"   ,"TRV"     , "HPQ"  , "STE"  , "CL"    , "APA" , "TOL" , "BKKT", "MELI" , "VRRM", "NRG" , input.symbol(defval = "Z"   , title = "Symbol 31", inline = "30", group = st))), [d31,s31] = req(31, tf("PTC"    ,"VICI"  , "SWKS" , "WAT" , "DECK"  , "HCC"  , "LOVE" , "MEG" , "ROST" , "GNK"  , "BEP" , input.symbol(defval = "AMZN", title = "Symbol 32", inline = "30", group = st)))
req(32, tf("TRMB"   ,"AFL"     , "GLW"  , "INCY" , "CAG"   , "FANG", "FNKO", "GPN" , "CVS"  , "GRAB", "XEL" , input.symbol(defval = "TSLA", title = "Symbol 33", inline = "32", group = st))), [d33,s33] = req(33, tf("DXC"    ,"ALL"   , "HWM"  , "COO" , "KMB"   , "PARR" , "GRBK" , "ADT" , "TPR"  , "TNP"  , "DTE" , input.symbol(defval = "AMD" , title = "Symbol 34", inline = "32", group = st)))
req(34, tf("JKHY"   ,"COF"     , "ENPH" , "PKI"  , "TTCF"  , "PSX" , "PHM" , "UPWK", "LULU" , "NAT" , "MAXN", input.symbol(defval = "GOOG", title = "Symbol 35", inline = "34", group = st))), [d35,s35] = req(35, tf("CDW"    ,"URI"   , "TXT"  , "BIO" , "SAM"   , "CVE"  , "NVR"  , "PAGS", "SFM"  , "TRMD" , "WEC" , input.symbol(defval = "NIO" , title = "Symbol 36", inline = "34", group = st)))
req(36, tf("PAYC"   ,"BK"      , "MPWR" , "VTRS" , "CPB"   , "PBF" , "STLA", "VERI", "KR"   , "TNK" , "BWXT", input.symbol(defval = "BABA", title = "Symbol 37", inline = "36", group = st))), [d37,s37] = req(37, tf("TYL"    ,"CBRE"  , "NTAP" , "CTLT", "STZ"   , "WTI"  , "GOLF" , "NOTV", "DKS"  , "TK"   , "PNW" , input.symbol(defval = "IBM" , title = "Symbol 38", inline = "36", group = st)))
req(38, tf("GEN"    ,"O"       , "TDY"  , "TFX"  , "TR"    , "SU"  , "SWK" , "ADV" , "W"    , "NSC" , "ED"  , input.symbol(defval = "AFRM", title = "Symbol 39", inline = "38", group = st))), [d39,s39] = req(39, tf("MTCH"   ,"ARE"   , "LDOS" , "TECH", "LEVI"  , "CPE"  , "LKQ"  , "IPG" , "ORLY" , "ALK"  , "KEN" , input.symbol(defval = "ABNB", title = "Symbol 40", inline = "38", group = st)))


type dropDown
    float data
    float coordinate
    string symbol


var histData = matrix.new<values>(40, 1), var scatterShapes = matrix.new<values>(7, 40), var pieShapes  = matrix.new<values>(4, 1)    , mid = 0
cArray       = array.new <values>(),      var gemMat  = matrix.new<dropDown>(10, 40), right = 0


b( float ) =>
   
    max - ((max - min) * float )

x( float , mult ) =>
   
    timeArray.get(math.round(math.max(timeArray.indexof( right) + (mid * (float + (.20 * mult))), 0)))

append(string , bool , int  ) =>
    
    if timeframe.change("M") and month == int
        histData.add_row(histData.rows())
        histData.add_col(histData.columns())
        histData.set(histData.rows() - 1, 0, values.new(yearCount = string + str.tostring(bool == false ? year : year - 1)))

        for i = 0 to symbolMat.columns() - 1
            histData.set(i, histData.columns() - 1, values.new(symbolData = symbolMat.get(0, i).symbolData))

if per == "FQ"

    append("Q3 ", false, 10), append("Q4 ", true , 1)
    append("Q1 ", false, 4 ), append("Q2 ", false, 7)

else 

    if ta.change(year)
        
        histData.add_row(histData.rows())
        histData.add_col(histData.columns())
        histData.set(histData.rows() - 1, 0, values.new(yearCount = str.tostring(year - 1)))
        for i = 0 to symbolMat.columns() - 1
            histData.set(i, histData.columns() - 1, values.new(symbolData = symbolMat.get(0, i).symbolData))


if barstate.islastconfirmedhistory

    if timeframe.multiplier < 240 and not timeframe.isdwm
        runtime.error("Please Select 4-Hour Chart or Greater Resolution")
    
    colCond = columns != "Pie Chart" and columns != "Drop Down"
    
    if intervalsback != 0 
        for i = 0 to 39
            n = histData.get(i, histData.columns() - intervalsback)
            
            if not na(n)
                symbolMat.set(0, i, values.new(symbolData = nz(n.symbolData)))

    string dateF = switch intervalsback != 0
        
        false => "Current"
        =>      histData.get(histData.rows() - intervalsback, 0).yearCount

    copy = values.new(dataArr = array.new_float(), symbolArr = array.new_string()), 

    
    for i = 0 to symbolMat.columns() - 1
        
        array.push(copy.dataArr   ,   symbolMat.get(0, i).symbolData)
        array.push(copy.symbolArr ,   symbolMat.get(1, i).symbol    )   

    if sort != "None" or columns == "Pie Chart" or columns == "Drop Down"
        
        
        if columns != "Pie Chart" and columns != "Drop Down"
            
            order = switch sort 
              
                "Descending" => order.ascending
                =>              order.descending
            
            copy.dataArr.sort(order)

        else 
       
            order = order.descending, copy.dataArr.sort(order)


        for i = 0 to copy.symbolArr.size() - 1
            for x = 0 to copy.symbolArr.size() - 1
                if symbolMat.get(0, i).symbolData == copy.dataArr.get(x)
                    copy.symbolArr.set(x, symbolMat.get(1, i).symbol)



    right := chart.right_visible_bar_time, left = chart.left_visible_bar_time, 
    mid := timeArray.indexof(left) - timeArray.indexof(right)
    
    newLeft = 
              
              math.round(
              math.min(
              timeArray.indexof(left) - (mid * .06), 
              timeArray.size() - 1))

    newRight = 
              
              math.round(
              math.max(
              timeArray.indexof(right) + (mid * .06), 0))
    
    mid2 =    
              
              math.round(
              math.avg(timeArray.indexof(newLeft), 
              timeArray.indexof( newRight))), 


    scatterShapes.set(6, 0, 
                        
                         values.new(
                             colmn = box.new(
                                 
                                  timeArray.get(newLeft), 
                                  max, 
                                  timeArray.get(newRight), 
                                  min, 
                                  bgcolor      = boxnobg and usebg ? cbg  : na, 
                                  border_color = boxnobg ? color.white : na, 
                                  xloc         = xloc.bar_time
                                   
                                   )))

    pieShapes.set(0, 0, values.new(l = timeArray.get(newLeft))),  pieShapes.set(1, 0, values.new(top = max))
    pieShapes.set(2, 0, values.new(r = timeArray.get(newRight))), pieShapes.set(3, 0, values.new(bot = min))

    adcalc        = (pieShapes.get(1, 0).top - pieShapes.get(3, 0).bot) / 20
    nCalc         = copy.dataArr.range() / 20, xz = -1, n = 0.0

    if colCond
        n := switch revScale 
            false => copy.dataArr.min()    
            =>       copy.dataArr.max()
    else
        n := copy.dataArr.min()


    strFix = switch revScale
        true   => copy.dataArr.max() < 0 ? "0" : str.tostring(copy.dataArr.max() + nCalc, "###,###.##")
        false  => copy.dataArr.min() > 0 ? "0" : str.tostring(copy.dataArr.min() - nCalc, "###,###.##")
    
    
    scatterShapes.set(1, 0, 
                         
                         values.new(
                             symbolLabel = label.new(
                                  
                                  pieShapes.get(2, 0).r, 
                                  pieShapes.get(3, 0).bot - adcalc, 
                                  text      = strFix, 
                                  color     = #ffffff00, 
                                  style     = label.style_label_left, 
                                  textcolor = dncol, 
                                  xloc      = xloc.bar_time, 
                                  size      = size.small
                                  
                                  )))
    

    for x = 0 to 39
        
        pos = str.pos(copy.symbolArr.get(x), ":"), sub = str.substring(copy.symbolArr.get(x), pos + 1), calcY = 0.0
        if colCond
            calcY  := switch revScale 
                false => (min) + ((max) - (min)) * (copy.dataArr.get(x) - copy.dataArr.min())  / (copy.dataArr.range())
                true  => (max) - ((max) - (min)) * (copy.dataArr.get(x) - copy.dataArr.min())  / (copy.dataArr.range())
        else 
            calcY := (min) + ((max) - (min)) * (copy.dataArr.get(x) - copy.dataArr.min())  / copy.dataArr.range()
        
        yax = switch x != xz
            true  and calcY < pieShapes.get(3, 0).bot    => pieShapes.get(3, 0).bot
            true  and calcY > pieShapes.get(1, 0).top    => pieShapes.get(1, 0).top
            => calcY

        scatterShapes.set(0, x, values.new(symbolLabel =
                
                 label.new(
                 timeArray.get(newRight + ((mid/48) * (x + 1))), 
                 yax, 
                 xloc      = xloc.bar_time, 
                 textcolor = color.white, 
                 color     = #ffffff00    , 
                 style     = label.style_label_center, 
                 text      = sub +"\n⦿", size = size.small, 
                 tooltip   = str.tostring(copy.dataArr.get(x), "###,###,###.00")
                 )))

        

        if x <= 19

            loopdn = kai.hsv_gradient(x, 0, 10, dncol,  midCol)
            loopup = kai.hsv_gradient(x, 11, 19, midCol, upcol), xTrack = -1

            col = switch xTrack != x
                
                true and x <= 10 => loopdn
                => loopup

            scatterShapes.set(1, x + 1, values.new(symbolLabel =
                
                             label.new(
                             pieShapes.get(2, 0).r,
                             pieShapes.get(3, 0).bot + (adcalc * x), 
                             text      = str.tostring(n, "###,###.##" ) , 
                             color     = #ffffff00, 
                             style     = label.style_label_left, 
                             textcolor = col, 
                             xloc      = xloc.bar_time, 
                             size      = size.small
                             )))
            
            if colCond
                
                switch revScale 
                
                    false => n += nCalc
                    =>       n -= nCalc
            else
              
                n += nCalc

            cArray.push(values.new(symbolColor = col))
    
    scatterShapes.set(1, 21, values.new(symbolLabel =
             
             label.new(
             pieShapes.get(2, 0).r,
             pieShapes.get(1, 0).top , 
             text      = str.tostring(colCond ? revScale == false ? copy.dataArr.max() : copy.dataArr.min() : copy.dataArr.max(), "###,###.##"), 
             color     = #ffffff00, 
             style     = label.style_label_left, 
             textcolor = upcol, 
             xloc      = xloc.bar_time, 
             size      = size.small
              )))




    pieShapes.set(1, 0, values.new(top = pieShapes.get(1, 0).top + adcalc)), scatterShapes.get(6, 0).colmn.set_top(pieShapes.get(1, 0).top) 

    strFix2 = switch revScale
        
        false => copy.dataArr.max() < 0 ? "0" : str.tostring(copy.dataArr.max() + nCalc, "###,###.##")
        true  => copy.dataArr.min() > 0 ? "0" : str.tostring(copy.dataArr.min() - nCalc, "###,###.##")

    scatterShapes.set(1, 22, 
                        
                         values.new(
                        
                             symbolLabel = label.new(
                                 
                                 pieShapes.get(2, 0).r, 
                                 pieShapes.get(1, 0).top, 
                                 text      = strFix2, 
                                 color     = #ffffff00, 
                                 style     = label.style_label_left, 
                                 textcolor = upcol, 
                                 xloc      = xloc.bar_time, 
                                 size      = size.small
                                 
                                 )))
    for i = 0 to 1
        cArray.push(values.new(symbolColor = upcol))

    pieShapes.set(3, 0, values.new(bot = pieShapes.get(3, 0).bot - adcalc)), scatterShapes.get(6, 0).colmn.set_bottom(pieShapes.get(3, 0).bot),  minLab = math.round(20e20)
    
    if boxnobg == false

        for i = 0 to 39
            minLab := math.min(minLab, scatterShapes.get(0, i).symbolLabel.get_x())
        
        for i = 0 to 1
            
            [x1, y1, x2, y2] = switch i != -1
                true and i == 0 => [minLab, pieShapes.get(3, 0).bot, timeArray.get(newRight), pieShapes.get(3, 0).bot                 ]
                =>                 [timeArray.get(newRight), pieShapes.get(3, 0).bot, timeArray.get(newRight), pieShapes.get(1, 0).top]
            
            scatterShapes.set(2, i, values.new(shapeLines = 
                 line.new(x1, y1, x2, y2,
                                      xloc = xloc.bar_time,
                                      color = color.white
                                      )))
                                      


    cArray.unshift(values.new(symbolColor = dncol)), sortedy = array.new_float()
    
    for i = 0 to 22
        sortedy.push(scatterShapes.get(1, i).symbolLabel.get_y())

    sortedy.sort(order.descending), cArray.reverse(), copyColor = array.new_int()

    for i = 0 to 39
        for x = 1 to 22
            if scatterShapes.get(0, i).symbolLabel.get_y() >= sortedy.get(x)
                if scatterShapes.get(0, i).symbolLabel.get_y() <= sortedy.get(x - 1)
                    scatterShapes.get(0, i).symbolLabel.set_textcolor(cArray.get(x).symbolColor), copyColor.push(x)

        pos = str.pos          (copy.symbolArr.get(i), ":") 
        sub = str.substring(copy.symbolArr.get(i), pos + 1) 
        
        scatterShapes.set(3, i, 
                             values.new(
                                 symbolLabel = label.new(          
                                     scatterShapes.get(0, i).symbolLabel.get_x(), 
                                     pieShapes.get(3, 0).bot, 
                                     style = label.style_label_up, 
                                     textcolor = color.white, 
                                     color = #ffffff00, 
                                     text = "╷\n" + sub,
                                     xloc = xloc.bar_time, 
                                     size = size.small
                                     
                                     )))
    
    for i = 1 to 39
        if scatterShapes.get(3, i).symbolLabel.get_x() == scatterShapes.get(3, i - 1).symbolLabel.get_x()
            scatterShapes.get(3, i).symbolLabel.set_text(scatterShapes.get(3, i).symbolLabel.get_text() + "\n" + scatterShapes.get(3, i - 1).symbolLabel.get_text())
            scatterShapes.get(3, i - 1).symbolLabel.delete()
            
    if columns == "Columns" or columns == "Scatter + Columns" or columns == "Bar"
        for i = 0 to 39
            coordinateE = timeArray.indexof(scatterShapes.get(0, 1).symbolLabel.get_x()) - timeArray.indexof(scatterShapes.get(0, 0).symbolLabel.get_x())
            
            [coordinateL, coordinateR] = switch columns 
                "Bar" => [timeArray.get(timeArray.indexof(scatterShapes.get(0, i).symbolLabel.get_x()) - math.round(coordinateE / 2)),
                          timeArray.get(timeArray.indexof(scatterShapes.get(0, i).symbolLabel.get_x()) + math.round(coordinateE / 2))]
                =>       [timeArray.get(timeArray.indexof(scatterShapes.get(0, i).symbolLabel.get_x())), 
                          timeArray.get(timeArray.indexof(scatterShapes.get(0, i).symbolLabel.get_x()))]

            scatterShapes.set(4, i, 
                             values.new(
                                 colmn = box.new(
                                     coordinateL, 
                                     scatterShapes.get(0, i).symbolLabel.get_y(),
                                     coordinateR, 
                                     pieShapes.get(3, 0).bot, 
                                     xloc = xloc.bar_time, 
                                     border_color = columns == "Bar" ? cbg : na,
                                     border_width = columns == "Bar" ? 3 : 1,
                                     bgcolor = na
                                     
                                     )))
        
            for x = 1 to sortedy.size() - 1
                if scatterShapes.get(4, i).colmn.get_top() >= sortedy.get(x)
                    if scatterShapes.get(4, i).colmn.get_top() <= sortedy.get(x - 1)
                        scatterShapes.get(4, i).colmn.set_bgcolor(cArray.get(x).symbolColor)
                        if columns != "Bar"
                            scatterShapes.get(4, i).colmn.set_border_color(cArray.get(x).symbolColor)


            if columns == "Columns"
                scatterShapes.get(0, i).symbolLabel.delete()
    
                
            if columns == "Bar"
                if i == 39 
                    if boxnobg == false 
                        scatterShapes.get(2, 0).shapeLines.set_x1(scatterShapes.get(4, 39).colmn.get_right())
                    else 
                        scatterShapes.get(6, 0).colmn.set_bottom(scatterShapes.get(6, 0).colmn.get_bottom() - adcalc)
                    for x = 0 to 39
                        scatterShapes.get(0, x).symbolLabel.delete()
    

    add = switch per
        
        "FQ" => " (FQ)\n" + px + "\n" + dateF
        "FY" => " (FY)\n" + px + "\n" + dateF
    
    
    scatterShapes.set(5, 0, 
                 values.new(
                         symbolLabel = label.new(
                                 math.round(math.avg(pieShapes.get(0, 0).l, pieShapes.get(2, 0).r)), 
                                 pieShapes.get(1, 0).top, 
                                 color     = #ffffff00, 
                                 textcolor = color.white, 
                                 size      = size.large, 
                                 text      = searchF == false ? typeInput1 + add :
                                 search + add, xloc = xloc.bar_time
                                 )))

    allL = label.all, allB = box.all, allLi = line.all

    if columns == "Pie Chart"
        

        if allL.size() > 0
            for i = 0 to allL.size() - 1
                allL.shift().delete()
        if allB.size() > 0
            for i = 0 to allB.size() - 1
                allB.shift().delete()
        if allLi.size() > 0 
            for i = 0 to allLi.size() - 1
                allLi.shift().delete()
      
        if mid > 20
            
            newRight2 = math.round(math.max(timeArray.indexof( right) + (mid * .55), 0))
            newLeft2  = math.round(math.max(timeArray.indexof( right) + (mid * .45), 0))
            
            sub       = timeArray.slice(newRight2, newLeft)
            sub2      = timeArray.slice(newRight, newLeft2)    
            pc        = array.new_float(), pc2 = array.new_float()
            
            for i = 0 to 19
                pc.push (copy.dataArr.get(i))
                pc2.push(copy.dataArr.get(i+20))

            perCumu = array.new_float(), perCumu2 = array.new_float()
            
            for i = 0 to 19
                pc.set(i,  pc.get(i)  + math.abs(pc.min() ))
                pc2.set(i, pc2.get(i) + math.abs(pc2.min()))

            for i = 0 to 19

                perCumu .push(pc.get(i) / pc.sum() / 5 * 100)
                perCumu2.push(pc2.get(i) / pc2.sum() / 5 * 100)

            percCumu = 0.0, percCumu2 = 0.0

            for i = 0 to 6
                pieShapes.add_row(pieShapes.rows())
                
            for i = 0 to 19
                
                    //  thanking @rumpypumpydumpy (on every iteration of this loop) for the easy-to-work-with framework! 
                
                pieShapes.set(4, pieShapes.columns() - 1,
                         values.new(shapeLines = 
                                 line.new( 
                                             sub.get(math.round(math.cos(2 * math.pi / 20 * percCumu) * ((math.round((newLeft - newRight2) / 2)) - 1) + 
                                             (math.round((newLeft2 - newRight) / 2))  - 1)),
                                             math.avg(max, min) + math.sin(2 * math.pi / 20 * percCumu) * math.avg(max, min), 
                                             sub.get(math.round(sub.size()/2) - 1), 
                                             math.avg(max,min), 
                     
                     xloc=xloc.bar_time, color = #000000, width = 2
                                             
                                             )))
                percCumu += perCumu.get(i)

                pieShapes.set(5, pieShapes.columns() - 1,
                         values.new(shapeLines = 
                                 line.new( 
                                             sub2.get(math.round(math.cos(2 * math.pi / 20 * percCumu2) * ((math.round((newLeft2 - newRight) / 2)) - 1) 
                                             + (math.round((newLeft2 - newRight) / 2)) - 1)), 
                                             math.avg(max, min) + math.sin(2 * math.pi / 20 * percCumu2) * math.avg(max, min), 
                                             sub2.get(math.round(sub2.size()/2) - 1), 
                                             math.avg(max,min), 
                   
                     xloc=xloc.bar_time, color = #000000, width = 2
                   
                                             )))
                percCumu2 += perCumu2.get(i)
                
                pieShapes.add_col(pieShapes.columns())


            for i = 4 to 5
            
                [initialSet, plus] = switch i != -1 
                    
                    true and i == 4 => [6, 0 ]
                    =>                 [8, 20]
                
                pieShapes.set(initialSet, 0, 
                         
                         values.new(
                         
                             symbolLabel = label.new(

                                 math.round(math.avg(pieShapes.get(i, 0).shapeLines.get_x1(), pieShapes.get(i, pieShapes.columns() - 2).shapeLines.get_x1())), 
                                 math.avg(pieShapes.get(i, 0).shapeLines.get_y1(), pieShapes.get(i,  pieShapes.columns() - 2).shapeLines.get_y1()), 
                                                         text      = copy.symbolArr.get(pieShapes.columns() - 2 + plus) 
                                                             + "\n" + str.tostring(copy.dataArr.get(pieShapes.columns()-2 + plus)),
                                                         color     = color.new(cArray.get(copyColor.get(pieShapes.columns() - 2 + plus)).symbolColor, 50),
                                                         xloc      = xloc.bar_time, 
                                                         style     = label.style_label_center, 
                                                         textcolor = color.white, 
                                                         size      = size.small
                                     )))

            for i = 1 to pieShapes.columns() - 1


                if not na(pieShapes.get(4, i))
                    
                    if perCumu.variance() < 1

                        pieShapes.set(6, i, 
                                 values.new(
                                                 shapeLinesFill=linefill.new(
                                                 pieShapes.get(4, i).shapeLines, 
                                                 pieShapes.get(4, i - 1).shapeLines, 
                                                 color.new(cArray.get(copyColor.get(i - 1)).symbolColor, 33
                                                     
                                                     ))))
                        if i == 1
                            
                            pieShapes.set(6, 0, 
                                 values.new(
                                                 shapeLinesFill = linefill.new(
                                                 pieShapes.get(4, 0).shapeLines, 
                                                 pieShapes.get(4, pieShapes.columns() - 2).shapeLines, 
                                                 color.new(cArray.get(copyColor.get(pieShapes.columns()-2)).symbolColor, 33
                                                     
                                                     ))))

                    else 
                        
                        pieShapes.get(4, i - 1).shapeLines.set_color(color.white)
                        pieShapes.get(4, i - 1).shapeLines.set_style(line.style_dotted)
                    
                    pieShapes.set(7, i, values.new(symbolLabel=label.new(
                            
                             math.round(math.avg(line.get_x1(pieShapes.get(4, i).shapeLines), line.get_x1(pieShapes.get(4, i - 1).shapeLines))), 
                             math.avg(line.get_y1(

                                                 pieShapes.get(4, i).shapeLines), line.get_y1(pieShapes.get(4, i - 1).shapeLines)), 
                                                 text      = copy.symbolArr.get(i - 1) + "\n" + str.tostring(copy.dataArr.get(i - 1)), 
                                                 color     = color.new(cArray.get(copyColor.get(i - 1)).symbolColor, 50),
                                                 xloc      = xloc.bar_time, 
                                                 style     = label.style_label_center, 
                                                 textcolor = color.white, 
                                                 size      = size.small
                              
                             )))
               
                if not na(pieShapes.get(5, i))

                    if perCumu2.variance() < 1

                        pieShapes.set(8, i, 
                                     values.new(
                                         shapeLinesFill=linefill.new(
                                         pieShapes.get(5, i).shapeLines, 
                                         pieShapes.get(5, i - 1).shapeLines, 
                                         color.new(cArray.get(copyColor.get(i + 20 - (i == pieShapes.columns() - 1 ? 1 : 0))).symbolColor, 
                                         33
                                         ))))
                        
                        if i == 1 
                           
                            pieShapes.set(8, 0, 
                                     values.new(
                                         shapeLinesFill = 
                                         linefill.new(pieShapes.get(5, 0).shapeLines, 
                                         pieShapes.get(5, pieShapes.columns() - 2).shapeLines, 
                                         color.new(cArray.get(copyColor.get(20)).symbolColor, 
                                         33
                                         ))))


                    else 
                       
                       
                        pieShapes.get(5, i - 1).shapeLines.set_color(color.white)
                        pieShapes.get(5, i - 1).shapeLines.set_style(line.style_dotted)
                    

                    pieShapes.set(9, i, 
                                 
                                 values.new(
                                 
                                     symbolLabel=label.new(
                                             math.round(math.avg(line.get_x1(pieShapes.get(5, i).shapeLines), line.get_x1(pieShapes.get(5, i - 1).shapeLines))), 
                                             math.avg(line.get_y1(pieShapes.get(5, i).shapeLines), line.get_y1(pieShapes.get(5, i - 1).shapeLines)), 
                                                          text = copy.symbolArr.get(20 + i - 1) + "\n" + str.tostring(copy.dataArr.get(20 + i - 1)), 
                                                          color     = 
                                                          color.new(cArray.get(copyColor.get(i + 20 - (i == pieShapes.columns() - 1 ? 1 : 0))).symbolColor, 50),
                                                          xloc      = xloc.bar_time, 
                                                          style     = label.style_label_center, 
                                                          textcolor = color.white, 
                                                          size      = size.small
                                             )))
            maxLine = 0.
            for i = 0 to pieShapes.columns() - 1
                if not na(pieShapes.get(4, i)) and not na(pieShapes.get(5, i))
                    maxLine := math.max(
                                             maxLine, 
                                             line.get_y1(pieShapes.get(4, i).shapeLines), 
                                             line.get_y1(pieShapes.get(5, i).shapeLines
                                             ))
            
            pieShapes.add_row(pieShapes.rows()), pieShapes.set(11, 0, 
                             values.new(
                                 symbolLabel = label.new(  
                                     math.round(math.avg(timeArray.get( newRight2), timeArray.get( newLeft2))), 
                                     maxLine, 
                                     color = #ffffff00, 
                                     textcolor = color.white, 
                                     size = size.large, 
                                     text =searchF == false ? typeInput1 + add: search + add, xloc = xloc.bar_time
                     )))

        else 
            
            label.new(  
                         math.round(math.avg(chart.left_visible_bar_time, chart.right_visible_bar_time)), 
                         math.avg(max, min), color = #ffffff00, 
                         xloc = xloc.bar_time, size = size.huge, text = "🥧"
                         
                         )

    if columns == "Drop Down"
        iTrack = -1, gm = gemMat
        
        if allL.size() > 0
            for i = 0 to allL.size() - 1
                allL.shift().delete()
        if allB.size() > 0
            for i = 0 to allB.size() - 1
                allB.shift().delete()
        if allLi.size() > 0 
            for i = 0 to allLi.size() - 1
                allLi.shift().delete()
      
        

        aId1 = array.from(.80, .84,  .80, .76, .86, .82, .78, .74, .88, .72)
        aId2 = array.from(.80, .84,  .80, .76, .86, .82, .78, .74, .88, .72)
        aId3 = array.from(.0,  .0 ,  .0,  .0,  .10, .10, .10, .10, .20, .20)
        aId4 = array.from(.0,  .10 , .10, .10, .20, .20, .20, .20, .30, .30)
        

        for i = 0 to 39
           
           
            gm.set(0,  i, dropDown.new(data    = copy.dataArr.get(i  )))
            gm.set(1,  i, dropDown.new(symbol  = copy.symbolArr.get(i)))
            
            if i <= 9
            
                gm.set(2,  i, dropDown.new(coordinate = aId1.get(i)))
                gm.set(3,  i, dropDown.new(coordinate = aId2.get(i)))
                gm.set(4,  i, dropDown.new(coordinate = aId3.get(i))) 
                gm.set(5,  i, dropDown.new(coordinate = aId4.get(i)))

        base = array.new_line(), basel = array.new_label(), xT = -1

        for x = 0 to 3

            for i = 0 to 9
            
                if x >= 1

                    plus = switch x != xT
                        
                        true and x == 1 => 10
                        true and x == 2 => 20
                        true and x == 3 => 30

                    gm.set(2,  i+plus, dropDown.new(coordinate =  gm.get(2 , i ) .coordinate - (.20 * x)))
                    gm.set(3,  i+plus, dropDown.new(coordinate =  gm.get(3 , i ) .coordinate - (.20 * x)))
                    gm.set(4,  i+plus, dropDown.new(coordinate =  gm.get(4,  i)  .coordinate))
                    gm.set(5,  i+plus, dropDown.new(coordinate =  gm.get(5,  i)  .coordinate))
        
                if i == 0                   
                
                    gm.set(6, x, dropDown.new(coordinate = .86 - (.20 * x))), gm.set(7, x, dropDown.new(coordinate = .74 - (.20 * x)))
                    gm.set(8, x, dropDown.new(coordinate = .72 - (.20 * x))), gm.set(9, x, dropDown.new(coordinate = .88 - (.20 * x)))



        for i = 0 to gm.columns() - 1
            
            xm = cArray, xb = copyColor
            
            fc = revScale == false ? reverse == false ? downcolor  : upcolor : reverse == false ? upcolor : downcolor
            
            basel.push(
                         label.new(
                                     x           = int(x(gm.get(3, i).coordinate, 0)), 
                                     y           = b    (gm.get(5, i).coordinate    ), 
                                     text        = gm.get(1, i).symbol + "\n" + str.tostring(gm.get(0, i).data),
                                     size        = size.small,  
                                     xloc        = xloc.bar_time, 
                                     style       = label.style_label_center, 
                                     textcolor   = color.white, 
                                     color       = color.new(i == gm.columns() - 1 ? fc : xm.get(xb.get(i)).symbolColor, 60)
                                     
                                     ))

            base.push(
                         line.new(
                                     int(x(gm.get(2, i).coordinate, 0)), b(gm.get(4, i).coordinate), 
                                     int(x(gm.get(3, i).coordinate, 0)), b(gm.get(5, i).coordinate), 
                                     xloc = xloc.bar_time, color = #ffffff
                            
                                     ))

            if i <= 3

                base.push(
                             line.new(
                                         int(x(gm.get(6, i).coordinate, 0)), b(.10), 
                                         int(x(gm.get(7, i).coordinate, 0)), b(.10), 
                                         xloc = xloc.bar_time, color = color.white
                                         ))

                base.push(
                             line.new(
                                         int(x(gm.get(8, i).coordinate, 0)), b(.20), 
                                         int(x(gm.get(9, i).coordinate, 0)), b(.20), 
                                         xloc = xloc.bar_time, color = color.white
                                         ))



        base.push(
                     line.new(
                                 int(x(.84, 0)), b(.0), int(x(.16, 0)), b(.0), 
                                 xloc = xloc.bar_time, color = color.white
                                 ))

bgcolor(usebg and boxnobg == false ? cbg : na)