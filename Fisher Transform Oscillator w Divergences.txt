//@version=5

//



indicator(title='Fisher Transform', overlay=false)



//

// Revisions: V3 by JustUncleL

// Original Author:  RicardoSantos

// Date:    4-Dec-2016

//

// Description:

//  Price Divergence detection for various methods : RSI, MACD, STOCH, VOLUME

//  ACC-DIST, FISHER, CCI, BB %B, Ehlers IdealRSI and Elders Force Index.

//

//

// Mofidifications:

//

//  3.1 20-Aug-2017

//      - Added Trend Volume Accumulation, this option really works only well

//        with Renko and HA candles. You have the option to use EMA for trend

//        direction change instead of candle bull/bear direction.

//      4-Aug-2017

//      - Added Elders Force Index

//      3-Aug-2017

//      - Updated to version 3 of Pinescript.

//      - Updated with some RichardoSantos revisions.

//

//  3.0 - Added option to disable/enable Hidden and Regular Divergence

//      - Added new divergence method BB %B (close only)

//      - Added new divergence mothod Ehlers IdealRSI (close only)

//

//  2.0 - original by RicardoSantos

//

// References:

//  Information on Divergence Trading:

//  - http://www.babypips.com/school/high-school/trading-divergences

//  - http://www.incrediblecharts.com/indicators/bollinger_percentage_b_band_width.php (BB %B)

//



// === INPUTS



//  ||  General Input:

method = input.string(defval='Fisher Transform', options=['RSI', 'MACD', 'Stochastic', 'Volume', 'Accumulation/Distribution', 'Fisher Transform', 'CCI', 'BB %B', 'Ideal RSI', 'Elders Force Index', 'Trend Acc Volume'])

SHOW_LABEL = input(title='Show Labels', defval=true)

SHOW_CHANNEL = input(title='Show Channel', defval=false)

uHid = input(true, title='Show Hidden Divergence')

uReg = input(true, title='Show Regular Divergence')

uTVAma = input(false, title='Use EMA Trend direction for Trend Acc Volume')

//  ||  RSI / STOCH / VOLUME / ACC/DIST/ FISHER/ CCI/ BB %B Input/Elders Force Index:

rsi_smooth = input(title='Length for Method (except MACD):', defval=2)


//  ||  MACD Input:

macd_src = input(title='MACD Source:', defval=close)

macd_fast = input(title='MACD Fast:', defval=12)

macd_slow = input(title='MACD Slow:', defval=26)

macd_smooth = input(title='MACD Smooth Signal:', defval=9)

//

high_src = high  // input(high,title="High Source")

low_src = low  // input(low,title="Low Source")



// === /INPUTS





//  ||  Functions:

f_top_fractal(_src) =>
    _src[4] < _src[2] and _src[3] < _src[2] and _src[2] > _src[1] and _src[2] > _src[0]

f_bot_fractal(_src) =>
    _src[4] > _src[2] and _src[3] > _src[2] and _src[2] < _src[1] and _src[2] < _src[0]

f_fractalize(_src) =>
    f_bot_fractal__1 = f_bot_fractal(_src)
    f_top_fractal(_src) ? 1 : f_bot_fractal__1 ? -1 : 0



//  ||••>   START MACD FUNCTION

f_macd(_src, _fast, _slow, _smooth) =>

    _fast_ma = ta.sma(_src, _fast)

    _slow_ma = ta.sma(_src, _slow)

    _macd = _fast_ma - _slow_ma

    _signal = ta.ema(_macd, _smooth)

    _hist = _macd - _signal
    _hist

//  ||<••   END MACD FUNCTION



//  ||••>   START ACC/DIST FUNCTION

f_accdist(_smooth) =>
    _return = ta.sma(ta.cum(close == high and close == low or high == low ? 0 : (2 * close - low - high) / (high - low) * volume), _smooth)
    _return

//  ||<••   END ACC/DIST FUNCTION



//  ||••>   START FISHER FUNCTION

sHigh = request.security(syminfo.tickerid , timeframe.period, high, barmerge.gaps_on)
sLow = request.security(syminfo.tickerid , timeframe.period, low, barmerge.gaps_on)

//sHigh = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, high)
//sLow = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, low)


//
_src = (sHigh + sLow) / 2
//
// Inputs

f_fisher(_src, _window) =>
    min_Median = ta.lowest(_src, _window)
    max_Median = ta.highest(_src, _window)
    temp = (_src - min_Median) / (max_Median - min_Median)
    value = 0.0
    value := .5 * 2 * ((temp - .5) + (.5 * nz(value[1])))
    value1 = value >= .9999 ? .9999 : value <= -.9999 ? -.9999 : value
    temp2 = (1 + value1) / (1 - value1)
    fisher_Value = 0.0
    fisher_Value := (.25 * math.log(temp2)) + (.5 * nz(fisher_Value[1]))
    fisher_Value

//  ||<••   END FISHER FUNCTION

d = f_fisher(high_src, rsi_smooth)

// Rolling Moving Average (or Wells Wilders MA)

irma(p, l) =>

    irma = 0.0

    irma := (nz(irma[1]) * (l - 1) + p) / l
    irma





// RSI function.

irsi(p, l) =>

    up = irma(math.max(ta.change(p), 0), l)

    down = irma(-math.min(ta.change(p), 0), l)

    irsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)
    irsi

//



//

// --- Start the Homodyne Discriminator Caculations

//

idealRSI(p) =>

    C1 = 0.0962

    C2 = 0.5769

    Df = 0.5

    Period = 0.0

    I2 = 0.0

    Q2 = 0.0

    Re = 0.0

    Im = 0.0

    SmoothPeriod = 0.0

    C3 = nz(Period[1]) * 0.075 + 0.54

    smooth = (hl2 * 4.0 + hl2[1] * 3.0 + hl2[2] * 2.0 + hl2[3]) / 10.0

    dDeTrend = (smooth * C1 + nz(smooth[2]) * C2 - nz(smooth[4]) * C2 - nz(smooth[6]) * C1) * C3

    Q1 = (dDeTrend * C1 + nz(dDeTrend[2]) * C2 - nz(dDeTrend[4]) * C2 - nz(dDeTrend[6]) * C1) * C3

    I1 = nz(dDeTrend[3])

    jI = (I1 * C1 + nz(I1[2]) * C2 - nz(I1[4]) * C2 - nz(I1[6]) * C1) * C3

    jQ = (Q1 * C1 + nz(Q1[2]) * C2 - nz(Q1[4]) * C2 - nz(Q1[6]) * C1) * C3

    I2_ = I1 - jQ

    Q2_ = Q1 + jI

    I2 := 0.2 * I2_ + 0.8 * nz(I2[1])

    Q2 := 0.2 * Q2_ + 0.8 * nz(Q2[1])

    Re_ = I2 * nz(I2[1]) + Q2 * nz(Q2[1])

    Im_ = I2 * nz(Q2[1]) - Q2 * nz(I2[1])

    Re := 0.2 * Re_ + 0.8 * nz(Re[1])

    Im := 0.2 * Im_ + 0.8 * nz(Im[1])

    dp_ = Re != 0 and Im != 0 ? 6.28318 / math.atan(Im / Re) : 0

    II = nz(Period[1])

    dp = math.max(math.max(math.min(math.min(dp_, 1.5 * II), 50), 0.6667 * II), 6)

    Period := dp * 0.2 + nz(Period[1]) * 0.8

    SmoothPeriod := 0.33 * Period + nz(SmoothPeriod[1]) * 0.67

    rsiLen = math.round(SmoothPeriod * Df - 1)  // Get variable RSI length from discriminator

    idealRSI = irsi(p, rsiLen)  // Generate RSI.
    idealRSI



// --- Bollinger Band Vdub BB %B

pcBB(p, l) =>

    basis = ta.sma(p, l)

    dev = 0.1 * ta.stdev(p, l)

    upper = basis + dev

    lower = basis - dev

    pcBB = (p - lower) / (upper - lower)
    pcBB



forceIndex(p, l) =>

    f = (p - p[1]) * volume

    f



//Trend Volume Accumulation

TVA(p, l) =>

    ma1 = ta.ema(p, l)  // Get the MA series

    direction = 0

    rising_1 = ta.rising(ma1, 3)
    falling_1 = ta.falling(ma1, 3)
    direction := uTVAma ? rising_1 ? 1 : falling_1 ? -1 : nz(direction[1]) : open < close ? 1 : open > close ? -1 : nz(direction[1])

    tva = 0.0

    tva := direction > 0 ? nz(tva[1]) >= 0 ? nz(tva[1]) + volume : volume : direction < 0 ? nz(tva[1]) <= 0 ? nz(tva[1]) - volume : -volume : nz(tva[1])

    tva



//

// === End of Functions.







//  ||  Method selection

oscilator_high = float(na)

oscilator_low = float(na)

if method == 'RSI'

    oscilator_high := ta.rsi(high_src, rsi_smooth)

    oscilator_low := ta.rsi(low_src, rsi_smooth)
    oscilator_low

if method == 'MACD'

    oscilator_high := f_macd(macd_src, macd_fast, macd_slow, macd_smooth)

    oscilator_low := f_macd(macd_src, macd_fast, macd_slow, macd_smooth)
    oscilator_low

if method == 'Stochastic'

    oscilator_high := ta.stoch(close, high, low, rsi_smooth)

    oscilator_low := ta.stoch(close, high, low, rsi_smooth)
    oscilator_low

if method == 'Volume'

    oscilator_high := ta.sma(volume, rsi_smooth)

    oscilator_low := ta.sma(volume, rsi_smooth)
    oscilator_low

if method == 'Accumulation/Distribution'

    oscilator_high := f_accdist(rsi_smooth)

    oscilator_low := f_accdist(rsi_smooth)
    oscilator_low

if method == 'Fisher Transform'

    oscilator_high := f_fisher(hl2, rsi_smooth)

    oscilator_low := f_fisher(hl2, rsi_smooth)
    oscilator_low

if method == 'CCI'

    oscilator_high := ta.cci(high_src, rsi_smooth)

    oscilator_low := ta.cci(low_src, rsi_smooth)
    oscilator_low

if method == 'BB %B'

    oscilator_high := pcBB(high_src, rsi_smooth)

    oscilator_low := pcBB(low_src, rsi_smooth)
    oscilator_low

if method == 'Ideal RSI'

    oscilator_high := idealRSI(high_src)

    oscilator_low := idealRSI(low_src)
    oscilator_low

if method == 'Elders Force Index'

    oscilator_high := forceIndex(high_src, rsi_smooth)

    oscilator_low := forceIndex(low_src, rsi_smooth)
    oscilator_low

if method == 'Trend Acc Volume'

    oscilator_high := TVA(high_src, rsi_smooth)

    oscilator_low := TVA(low_src, rsi_smooth)
    oscilator_low



//

fractal_top = f_fractalize(oscilator_high) > 0 ? oscilator_high[2] : na

fractal_bot = f_fractalize(oscilator_low) < 0 ? oscilator_low[2] : na



high_prev = ta.valuewhen(fractal_top, oscilator_high[2], 0)[2]

high_price = ta.valuewhen(fractal_top, high[2], 0)[2]

low_prev = ta.valuewhen(fractal_bot, oscilator_low[2], 0)[2]

low_price = ta.valuewhen(fractal_bot, low[2], 0)[2]



regular_bearish_div = fractal_top and high[2] > high_price and oscilator_high[2] < high_prev

hidden_bearish_div = fractal_top and high[2] < high_price and oscilator_high[2] > high_prev

regular_bullish_div = fractal_bot and low[2] < low_price and oscilator_low[2] > low_prev

hidden_bullish_div = fractal_bot and low[2] > low_price and oscilator_low[2] < low_prev



trendColor = d > d[1] ? color.green : color.red

//fishplot = plot(d, title="Fisher", color=trendColor, transp=0, linewidth=4)

z1 = f_fisher(_src, rsi_smooth)

plot(z1, color=trendColor, linewidth=1)


// Plotting

plot(title='H F', series=fractal_top ? oscilator_high[2] : na, color=regular_bearish_div and uReg or hidden_bearish_div and uHid ? color.maroon : not SHOW_CHANNEL ? na : color.silver, offset=-2)

plot(title='L F', series=fractal_bot ? oscilator_low[2] : na, color=regular_bullish_div and uReg or hidden_bullish_div and uHid ? color.green : not SHOW_CHANNEL ? na : color.silver, offset=-2)

plot(title='H D', series=fractal_top ? oscilator_high[2] : na, style=plot.style_circles, color=regular_bearish_div and uReg or hidden_bearish_div and uHid ? color.maroon : not SHOW_CHANNEL ? na : color.silver, linewidth=3, offset=-2)

plot(title='L D', series=fractal_bot ? oscilator_low[2] : na, style=plot.style_circles, color=regular_bullish_div and uReg or hidden_bullish_div and uHid ? color.green : not SHOW_CHANNEL ? na : color.silver, linewidth=3, offset=-2)



//plotshape(title='+RBD', series=not SHOW_LABEL or not uReg ? na : regular_bearish_div ? oscilator_high[2] : na, text='R', style=shape.labeldown, location=location.absolute, color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), offset=-2)

//plotshape(title='+HBD', series=not SHOW_LABEL or not uHid ? na : hidden_bearish_div ? oscilator_high[2] : na, text='H', style=shape.labeldown, location=location.absolute, color=color.new(color.maroon, 0), textcolor=color.new(color.white, 0), offset=-2)

//plotshape(title='-RBD', series=not SHOW_LABEL or not uReg ? na : regular_bullish_div ? oscilator_low[2] : na, text='R', style=shape.labelup, location=location.absolute, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), offset=-2)

//plotshape(title='-HBD', series=not SHOW_LABEL or not uHid ? na : hidden_bullish_div ? oscilator_low[2] : na, text='H', style=shape.labelup, location=location.absolute, color=color.new(color.green, 0), textcolor=color.new(color.white, 0), offset=-2)

