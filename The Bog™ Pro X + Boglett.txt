// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Uni_ve12se

//@version=2
//
study(title="The Bog™ Pro X + Boglett", shorttitle="The Bog™ Pro X (Buckkets and Futur)", overlay=false, max_bars_back=5000)

//Boglett Switch
boglettswitch = input(true, title="Check for Bog.  Uncheck for Boglett")

modeswitch = input(false, title="Check for Auto Length (Non Fixed lookback)")

n1 = input(14, title="Channel Length (Default 14)")
n2 = input(27, title="Average Length (Default 27)")
n3 = input(3, title="Signal Length (Default 3)")

m1 = input(7, title="second Channel Length (Default 7)")
m2 = input(14, title="Second Average Length (Default 14)")
m3 = input(3, title="Second Signal Length (Default 3)")

//Patch notes
//Added switches for labels 6/29
//Predictor line added 7/1

//Corrected render issue

//Color change
//Menu change

//Custom colors
botcol = #15B1E0
tcol = #DF6F00

sigcol  = #15B1E0
maincol = #D4D4D4

beta_tcol = #00B48A
beta_sigcol = #017358

//Switches
divmode = input(false, title="Show Divergences?")
crossmode = input(false, title="Show Crosses?")
predictormode = input(false, title="Show Predictor Line?")

secondbog = input(false, title="Plot Second Bog")
//comboswitch = input(false, title="Plot Bog Combo Line")


// --- Start the Homodyne Discriminator Caculations
//
// Mutable Variables (non-series)
C1     = 0.0962
C2     = 0.5769
Df     = 0.5

//
C3      = (nz(Period[1])*0.075+0.54)
smooth    = ((hl2*4.0) + (hl2[1]*3.0) + (hl2[2]*2.0) + (hl2[3]))/10.0
dDeTrend  = (smooth*C1 + nz(smooth[2])*C2 - nz(smooth[4])*C2 - nz(smooth[6])*C1)*C3

// Compute InPhase and Quadrature components
Q1      = (dDeTrend*C1 + nz(dDeTrend[2])*C2 - nz(dDeTrend[4])*C2 - nz(dDeTrend[6])*C1)*C3
I1      = nz(dDeTrend[3])

// Advance Phase of I1 and Q1 by 90 degrees
jI      = (I1*C1 + nz(I1[2])*C2 - nz(I1[4])*C2 - nz(I1[6])*C1)*C3
jQ      = (Q1*C1 + nz(Q1[2])*C2 - nz(Q1[4])*C2 - nz(Q1[6])*C1)*C3

// Phaser addition for 3 bar averaging
I2_  = I1 - jQ
Q2_  = Q1 + jI
// Smooth i and q components before applying discriminator
I2  = 0.2*I2_ + 0.8*nz(I2[1])
Q2  = 0.2*Q2_ + 0.8*nz(Q2[1])

// Extract Homodyne Discriminator
Re_ = I2*nz(I2[1]) + Q2*nz(Q2[1])
Im_ = I2*nz(Q2[1]) - Q2*nz(I2[1])
Re  = 0.2*Re_ + 0.8*nz(Re[1])
Im  = 0.2*Im_ + 0.8*nz(Im[1])

dp_ = iff(Re!=0 and Im!=0 , 6.28318/atan(Im/Re) , 0)
II  = nz(Period[1])
dp  = max(max(min(min(dp_,1.5*II),50),0.6667*II),6)
Period = dp*0.2 + nz(Period[1])*0.8
SmoothPeriod = 0.33*Period + nz(SmoothPeriod[1])*0.67
BogLength = round(SmoothPeriod*Df -1)

//ap = hlc3
data = heikenashi(tickerid)
o = security(data, period, open)
h = security(data, period, high)
l = security(data, period, low)
c = security(data, period, close)

//ZLEMA function
ZLEMA(sauce, nPeriod)=>
    xLag = (nPeriod - 1) / 2
    xEMAData = (sauce + (sauce - sauce[xLag]))
    xZLEMA = ema(xEMAData, nPeriod)

looplength = 100
num = 4

for i = 0 to looplength
    if (i >= BogLength)
        break
    num:=num + 1
num :=num*2

//SMA to EMA change
ap = (h + l + c)/3
esa = sma(ap, num)
d = sma(abs(ap - esa), num)

//(ap - zlema) / (0.015 * d (modded zlema))
ci = (ap - esa) / (0.015*  d)
tci = sma(ci, round(num))

//OG BOG code
bog(ap, len1, len2)=>
    esa1 = sma(ap, len1)
    d1 = sma(abs(ap - esa1), len1)
    ci1 = (ap - esa1) / (0.015*  d1)
    tci2 = ZLEMA(ci1, len2)

//Normal WT code
bog1 = modeswitch ? tci : bog(ap, n1, n2)
bog2 = sma(bog1,n3)

bog2_1 = modeswitch ? na : bog(ap, m1, m2)
bog2_2 = sma(bog2_1, m3)

////////////////////////////////////////////////////////
//Boglett code 
boglettlookback = input(2, title="Boglett Smoothing (Recommended '2')")

boglett1 = change(bog1, boglettlookback)
boglett2 = change(bog2_1, boglettlookback)

/////////////////////////////////////////////////////////
//Predictor line
momentum = bog1 - nz(bog1[1])
normalized = momentum * (num/(2*3.141592)) * 0.577 //arctan(30)
reduce = normalized
 //reduce amplitude
predictor = (bog1 + reduce) *  0.877 *0.75

//Adaptive oversold/overbought
obLevel1 = highest(bog1, n2*8)
obLevel2 = obLevel1 - 15

osLevel1 = lowest(bog1, n2*8)
osLevel2 = osLevel1 + 15

///////////////Normal plots
bgcolor(black, title="Indicator Background", transp=0)
mid1 = plot(0, color=gray, editable=false)

ob1 = plot(boglettswitch ? (secondbog ? na : obLevel1) : na, title="Overbought Level 1", color=tcol, style=circles, transp=0)
ob2 = plot(boglettswitch ? (secondbog ? na : obLevel2) : na, title="Overbought Level 2", color=tcol, style=circles, transp=0)

os1 = plot(boglettswitch ? (secondbog ? na : osLevel1) : na, title="Oversold Level 1", color=botcol, style=circles, transp=0)
os2 = plot(boglettswitch ? (secondbog ? na : osLevel2) : na, title="Oversold Level 2", color=botcol, style=circles, transp=0)

fill(ob1, ob2, title="Overbought Fill Color", color=tcol, transp=60)
fill(os1, os2, title="Oversold Fill Color", color=botcol, transp=60)

b1 = fill(mid1, ob2, title="Top Background Color", color = tcol, transp=80)
b2 = fill(mid1, os1, title="Bottom Background Color", color = botcol, transp=80)

/////Divergence indicator
f_t_frc(_src)=>_src[4] < _src[2] and _src[3] < _src[2] and _src[2] > _src[1] and _src[2] > _src[0]
f_bot_frc(_src)=>_src[4] > _src[2] and _src[3] > _src[2] and _src[2] < _src[1] and _src[2] < _src[0]
f_frcize(_src)=>f_t_frc(_src) ? 1 : f_bot_frc(_src) ? -1 : 0

bog_high = bog1
bog_low = bog2

frc_t_bog = f_frcize(bog_high) > 0 ? bog_high[2] : na
frc_bot_bog = f_frcize(bog_low) < 0 ? bog_low[2] : na

bog_high_prev = valuewhen(frc_t_bog, bog_high[2], 1)
bog_high_price = valuewhen(frc_t_bog, high[2], 1)
bog_low_prev = valuewhen(frc_bot_bog, bog_low[2], 1)
bog_low_price = valuewhen(frc_bot_bog, low[2], 1)

regular_bearish_div = frc_t_bog and high[2] > bog_high_price and bog_high[2] < bog_high_prev
hidden_bearish_div = frc_t_bog and high[2] < bog_high_price and bog_high[2] > bog_high_prev
regular_bullish_div = frc_bot_bog and low[2] < bog_low_price and bog_low[2] > bog_low_prev
hidden_bullish_div = frc_bot_bog and low[2] > bog_low_price and bog_low[2] < bog_low_prev

///////////

plot(boglettswitch ? bog1 : boglett1, title="Bog line", color=tcol, linewidth=2, transp=0)
plot(boglettswitch ? bog2 : na, title="Bog signal line", color=white, linewidth=2, transp=0)

plot(boglettswitch ? (secondbog and not modeswitch ? bog2_1 : na) : (secondbog ? boglett2 : na), title="Second Bog Line", color=botcol, linewidth=2)
plot(boglettswitch ? (secondbog and not modeswitch ? bog2_2 : na) : na, title="Second Bog Signal Line", color=silver, linewidth=2)

////////Cross plots
//Plot the crosses

plot(crossmode and cross(bog1, bog2) ? bog2 : na, color = white, title="Cross color", style = circles, linewidth = 6, transp=0)

plot(boglettswitch ? (predictormode ? predictor : na) : na, color=aqua, title="Predictor Line", style=circles, join=true, linewidth=2, transp=0)


plotshape(divmode ? (regular_bearish_div ? bog_high[2] : na) : na, title='Regular Bearish Divergence', text='BearDiv', style=shape.labeldown, location=location.absolute, color=white, textcolor=black, offset=-2, transp=0)
plotshape(divmode ? (hidden_bearish_div ? bog_high[2] : na) : na, title='Hidden Bearish Divergence', text='BearDiv', style=shape.labeldown, location=location.absolute, color=white, textcolor=black, offset=-2, transp=0)

plotshape(divmode ? (regular_bullish_div ? bog_low[2] : na) : na, title='Regular Bullish Divergence', text='BullDiv', style=shape.labelup, location=location.absolute, color=white, textcolor=black, offset=-2, transp=0)
plotshape(divmode ? (hidden_bullish_div  ? bog_low[2] : na) : na, title='Hidden Bullish Divergence', text='BullDiv', style=shape.labelup, location=location.absolute, color=white, textcolor=black, offset=-2, transp=0)